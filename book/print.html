<!DOCTYPE HTML>
<html lang="hu" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>A Programozás Alapjai 2. - Lipódi László jegyzete</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="-Inspiracio.html"><strong aria-hidden="true">1.</strong> Kezdőoldal</a></li><li class="chapter-item expanded "><a href="0-alapveto-kulonbsegek.html"><strong aria-hidden="true">2.</strong> Alapvető különbségek a C nyelvtől</a></li><li class="chapter-item expanded "><a href="1-standard-io.html"><strong aria-hidden="true">3.</strong> Standard IO</a></li><li class="chapter-item expanded "><a href="2-kivetelek.html"><strong aria-hidden="true">4.</strong> Kivételek</a></li><li class="chapter-item expanded "><a href="3-dinamikus-memoriakezeles.html"><strong aria-hidden="true">5.</strong> Dinamikus memóriakezelés</a></li><li class="chapter-item expanded "><a href="4-sablonok.html"><strong aria-hidden="true">6.</strong> Sablonok</a></li><li class="chapter-item expanded "><a href="5-osztályok.html"><strong aria-hidden="true">7.</strong> Osztályok, RAII</a></li><li class="chapter-item expanded "><a href="6-operator-overloading.html"><strong aria-hidden="true">8.</strong> Operator overloading</a></li><li class="chapter-item expanded "><a href="7-inheritance.html"><strong aria-hidden="true">9.</strong> Objektumorientált programozás idióma</a></li><li class="chapter-item expanded "><a href="8-heterogen_kollekcio.html"><strong aria-hidden="true">10.</strong> Heterogén kollekció</a></li><li class="chapter-item expanded "><a href="9-iterátorok.html"><strong aria-hidden="true">11.</strong> Iterátorok</a></li><li class="chapter-item expanded "><a href="10-predikátumok-funktorok.html"><strong aria-hidden="true">12.</strong> Predikátumok, funktorok</a></li><li class="chapter-item expanded "><a href="11-STL.html"><strong aria-hidden="true">13.</strong> STL</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">A Programozás Alapjai 2. - Lipódi László jegyzete</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="a-jegyzetről"><a class="header" href="#a-jegyzetről">A jegyzetről</a></h1>
<p><em><strong>FONTOS!</strong></em> A C++ nyelv a népszerű nyelvek között az egyik legnehezebb, elsajátítása megfelelő figyelmet és erőbefektetést igényel. A jegyzetben minden sornak jelentése van, azokban potenciálisan olyan információ rejlik, amely később kritikus tudásként szolgálhat. Érdemes minden sort elolvasni és értelmezni a kódrészleteket. A programozás tényleges megtanulásához elengedhetetlen, hogy hallgatóként a programozásra hobbiként is tekintsünk.</p>
<p>A jegyzet A Programozás Alapjai 2 című tárgyhoz készült, viszont egyes esetekben kitérőket tesz, hogy az esetleges C++ nyelv iránt érdeklődő hallgatókat elmélyítse a nyelv szépségeiben.</p>
<p>A jegyzetben próbáltam a tananyag menetéhez alkalmazkodni, csak akkor változtattam, amikor a tananyagban esetleg érdemesebbnek láttam egyes fogalmakat hamarabb bevezetni.</p>
<p>A legtöbb anyaghoz találhatóak külső linkek hasznos oldalakhoz, azonban egyesek(pl. cppreference) kicsit bővebben elmagyaráznak egyes aspektusokat, mint ami a tárgyhoz szükséges.</p>
<p>Ezen felül fontos azt megjegyezni, hogy a tárgy C++ verzióban inkonzisztens(pl. egyes ellenőrző feladatok C++03-ra vannak állítva), néhány laboron működni fog az, ami a másikon nem. Viszont a házi feladatban <em>elvileg</em> C++17 verzióval fordul minden.
A laborokon elvileg lehet(és Windowson ezt ajánlom!) Visual Studioban dolgozni, ami viszont C++14-nél régebbi verziókat nem támogat.</p>
<h1 id="compiler-explorergodbolt"><a class="header" href="#compiler-explorergodbolt">Compiler Explorer(Godbolt)</a></h1>
<p>A <a href="https://godbolt.org/z/xPK1P37P8">Compiler Explorer</a> egy weboldal, ahol mindenféle nyelven írt programok különböző fordítókkal készített kimenetét lehet megnézni. A linkre kattintva egy egyszerű setupot kapunk, amelyen a bal oldalra írt kódot a jobb oldalon optimalizálás nélküli Assemblyként láthatjuk, valamint egy "Executor" is jelen van, amely a kód futtatását szimulálja.
(Ha nem érdekel az assembly, azt a tabot nyugodtan bezárhatod, telhesen független az Executor-tól.)</p>
<p>A jegyzetben a hosszabb/bonyolultabb kódrészletekhez csatoltam godbolt linkeket, így gyorsan csekkolható a program futása, valamint így gyorsan bele lehet piszkálni a kódba.</p>
<p><img src="image-4.png" alt="alt text" /></p>
<h1 id="inspiráció"><a class="header" href="#inspiráció">Inspiráció</a></h1>
<p>A jegyzet inspirációt merít az <a href="https://infocpp.iit.bme.hu">infocpp</a>(hivatalos tárgyhonlap, tananyag), <a href="https://prog2.cppftw.org">CPPFTW</a>(hallgatók által készített majdnem kész jegyzet) és a <a href="https://en.cppreference.com/w/">cppreference</a> weboldal tartalmából.</p>
<p>Köszönöm a <a href="https://discord.gg/tccpp">TCCPP</a> Discord szerver tapasztalt(gcc közreműködők, C++ ISO tanács tagok) tagjainak az esetleges szakmai kérdések megválaszolását.</p>
<ul>
<li>volatile</li>
<li>Mr. Σ</li>
<li>Eisenwave</li>
<li>dot</li>
<li>DXPower</li>
</ul>
<p>Az "Alapvető különbségek a C nyelvtől" fejezet alcímeit és tartalmát részben a CPPFTW oldal inspirálta.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="alapvető-különbségek-a-c-nyelvtől"><a class="header" href="#alapvető-különbségek-a-c-nyelvtől">Alapvető különbségek a C nyelvtől</a></h1>
<h2 id="a-bool-mint-nyelvi-elem"><a class="header" href="#a-bool-mint-nyelvi-elem">A <code>bool</code>, mint nyelvi elem</a></h2>
<p><a href="https://en.cppreference.com/w/cpp/language/types#Boolean_type">https://en.cppreference.com/w/cpp/language/types#Boolean_type</a></p>
<p>A <code>bool</code> típus, habár a C nyelv újabb verzióiban nyelvi elemként szerepel, a Prog1 még nem tanítja. A C++ nyelvnek szerencsére része a <code>bool</code> típus, nem kell ehhez a legújabb verziókat használni.</p>
<pre><code class="language-cpp">bool x = true; //nem kell semmilyen include
</code></pre>
<h2 id="struktúra-és-typedef"><a class="header" href="#struktúra-és-typedef">Struktúra és typedef</a></h2>
<p>A C nyelvben a struktúrák önmagukban nem, csak a <code>struct</code> előtaggal voltak egyéni típusnevek. Ez C++ -ban másképp van, itt a struktúra neve <code>typedef</code> nélkül is egyéni típusnév.</p>
<pre><code class="language-cpp">struct foo{
    int a;
};

int main(){
    foo f;
    f.a = 5;
}
</code></pre>
<h2 id="c-standard-library-headerek"><a class="header" href="#c-standard-library-headerek">C Standard Library headerek</a></h2>
<p>A C standard library header-jei a C++ nyelvben is léteznek, viszont a <code>.h</code> kiterjesztést elvesztették, és egy <code>c</code> előtagot kaptak. Pl.</p>
<pre><code>#include &lt;stdio.h&gt; -&gt; #include &lt;cstdio&gt;
</code></pre>
<h2 id="névtereknamespace"><a class="header" href="#névtereknamespace">Névterek(namespace)</a></h2>
<p><a href="https://en.cppreference.com/w/cpp/language/namespace">https://en.cppreference.com/w/cpp/language/namespace</a></p>
<p>C-ben gyakori az, hogy egy név már használva van például egy header file-ban ezért bárhol, ahol ez a header include-olva van, ez a név "foglalt" lesz. Ezt sok könyvtár a név prefixelésével oldja meg, pl. <code>SDL_Texture</code>.</p>
<p>Erre a C++ -nak beépített nyelvi eleme van, ezek pedig a névterek.</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;

namespace foo{
    void f(){
        std::printf("foo");
    }

    namespace bar{
        void f(){
            std::printf("bar");
        }
    }
}

int main(){
    foo::f();
    foo::bar::f();
}
</code></pre>
<p>A névtereken belüli neveket a <code>::</code> operátorral érhetjük el. A <code>printf</code> előtti <code>std</code> névtér a standard library névtere, ez tartalmazza az összes standard library által tartalmazott szimbólumot(függvények, struktúrák, stb.), éppen azért, hogy az stdlib által használt gyakori nevek(pl. vector) ne ütközzenek más kóddal.</p>
<h2 id="function-overloading"><a class="header" href="#function-overloading">Function overloading</a></h2>
<p>C++ -ban ugyanazon nevű függvény többféle paramétereket vehet át.</p>
<pre><code class="language-cpp">#include &lt;cstdio&gt;

void foo(double x){
    std::printf("%lf double", x);
}

void foo(int x){
    std::printf("%d int", x);
}

int main(){
    foo(5); // 5 int
    foo(3.2); // 3.2 double
}
</code></pre>
<h2 id="referenciák"><a class="header" href="#referenciák">Referenciák</a></h2>
<p>C-ből ismert a pointerek fogalma. Ezt sokszor arra használjuk, hogy egy függvényben a paraméterként kapott eredeti objektumot módosítsuk, vagy hogy egy másolást elkerüljünk.
Erre valók C++ban a <em>referenciák</em></p>
<pre><code class="language-cpp">//swap függvény C-ben

void c_swap(int* x, int* y){
    int tmp = *x;
    *x = *y;
    *y = tmp;
}

//swap C++ -ban
void cpp_swap(int&amp; x, int&amp; y){
    int tmp = x;
    x = y;
    y = tmp;
}
</code></pre>
<p>A referenciák konstansok, azaz egy referencia az élettartama alatt nem tud hirtelen másik objektumra mutatni.</p>
<pre><code class="language-cpp">int x = 5;
int y = 1;
int&amp; xr = x;
xr = y; //ugyan az, mint x = y;
</code></pre>
<p>Gondolhatunk a referenciára úgy, mint egy 'alias' -ra (alternatív név). Megmondjuk, minek az alias-a, majd utána az eredeti változó helyett használjuk.</p>
<p>Fontos megjegyezni, hogy ugyan úgy mint a pointereknél, lokális változóra mutató referenciával <em>tilos</em> visszatérni.</p>
<h2 id="a-const-kulcsszó"><a class="header" href="#a-const-kulcsszó">A const kulcsszó</a></h2>
<p><a href="https://en.cppreference.com/w/cpp/language/cv">https://en.cppreference.com/w/cpp/language/cv</a></p>
<p>Most a <code>const</code> <em>type qualifier</em>-ről van szó.</p>
<p>A <code>const</code> kulcsszó a C nyelvnek is része, viszont C++ban egy sokkal fontosabb szerepe van, amivel később találkozunk még.</p>
<p>Jelentése nevéből adódik, egy <code>const</code> objektumot "nem lehet megváltoztatni". A kulcsszó mindig a tőle azonnal balra található dologra vonatkozik, kivéve ha a <code>const</code> az első, akkor a tőle azonnal jobbra található elemre vonatkozik.
Fontos azt megemlíteni, hogy a <code>const</code> nem fordításidejű konstans értéket jelöl, inkább a programozó felé jelzés. Régebben a fordítók optimalizálásra is használták, viszont ennek a jelentősége ma már elenyésző, viszont a kulcsszó használata ettől még esszenciális marad.</p>
<p>Pélák:</p>
<pre><code class="language-cpp">int x; // sima, változtatható egész
int const pi = 3.14; //konstans egész
const int pi = 3.14; //ugyanaz, mint az előző

const int* p = &amp;pi; // pointer egy konstans egészre
int const * p = &amp;pi; //ugyanaz, mint az előző

const int&amp; p = pi; //referencia konstans egészre
int const&amp; p = pi; //ugyanaz, mint az előző

//most jön a lényeg

const int* const c = &amp;pi; //konstans pointer konstans egészre
int const * const c = &amp;pi; //ugyanaz, mint az előző

int* const c = &amp;x; // konstans pointer változtatható egészre

/*!!!---!!!*/
//az alábbi kódrészletek pedig nem működnek, mivel konstans objektumra csak pointer-to-const és reference-to-const mutathat

//mivel pi const, ezért csak pointer-to-const mutathat rá
int* const c = &amp;pi; 

//mivel pi const, ezért csak reference-to-const referálhat rá
int&amp; r = pi; 
</code></pre>
<h2 id="null-pointer"><a class="header" href="#null-pointer">Null pointer</a></h2>
<p><a href="https://en.cppreference.com/w/cpp/language/nullptr">https://en.cppreference.com/w/cpp/language/nullptr</a></p>
<p>A régebbi(prog1en oktatott) C verziókban a <code>NULL</code> valójában a konstans 0 void* -é kasztolása. C++ban a <code>void*</code> -&gt; <code>T*</code> konverzió nem implicit, így C++ban a null pointernek saját <code>std::nullptr_t</code> típusa van, és <a href=""><code>nullptr</code></a> -ként hivatkozunk rá a kódban. Az <code>std::nullptr_t</code> típust a saját kódunkban nem fogjuk használni, viszont annyit kell tudni róla, hogy bármilyen pointer típussá és <code>bool</code>-ra is képes implicit konvertálódni, azaz működnek a</p>
<pre><code class="language-cpp">int* a = nullptr;

if(a) {

}
</code></pre>
<p>kódrészletek.</p>
<h2 id="stdstring"><a class="header" href="#stdstring">std::string</a></h2>
<p><a href="https://en.cppreference.com/w/cpp/string/basic_string">https://en.cppreference.com/w/cpp/string/basic_string</a></p>
<p>Egy egyszerű string típus dinamikus mérettel és alap elvárt string funkcionalitással.</p>
<pre><code class="language-cpp">#include &lt;string&gt;
/* ... */
std::string str = "foo";
std::string str2 = str;

str = str.substr(0, 1);
// ...
</code></pre>
<h2 id="scoped-enumc11"><a class="header" href="#scoped-enumc11">Scoped enum(C++11)</a></h2>
<p><a href="https://en.cppreference.com/w/cpp/language/enum">https://en.cppreference.com/w/cpp/language/enum</a></p>
<p>A C <code>enum</code> típusai nagyon furcsán viselkednek, egésszé változnak ha kicsit féloldalasan nézzük őket, pedig nem igazán erre valók. C++ban az <code>enum class</code> ezt oldja meg.
Definíciós szintaxisuk a C enumokhoz hasonló, viszont a scoped enum-ok nem konvertálódnak automatikusan egész számokká, valamint nem valami mágikus globális konstansként próbálnak viselkedni.</p>
<pre><code class="language-cpp">enum class Direction{
    UP=0, DOWN=1, LEFT=2, RIGHT=3
};

int main(){
    Direction d = Direction::UP; //typename::enumname szintaxis
    int x = d; //error
}
</code></pre>
<p>Még egy nagyon jó tulajdonságuk, hogy megadhatjuk az underlying típusukat. Például ha tudjuk hogy max 1 bytera lesz szükségünk, akkor megmondhatjuk neki, hogy valójában egy speckó <code>char</code> legyen.</p>
<pre><code class="language-cpp">enum class Direction : char{
    UP=0, DOWN=1, LEFT=2, RIGHT=3
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="standard-io"><a class="header" href="#standard-io">Standard IO</a></h1>
<h2 id="problémák-a-c-standard-io-val"><a class="header" href="#problémák-a-c-standard-io-val">Problémák a C standard IO-val</a></h2>
<p>A <code>printf</code> és <code>scanf</code> fő problémája a compile time hibaellenőrzés hiánya. Nincs típusellenőrzés, így gyakran lesznek ezekkel a függvényekkel kapcsolatban problémáink. A <code>scanf</code> függvénynél ezen felül nem szabad elfelejteni a címképző operátort(<code>&amp;</code>) sem, a <code>printf</code> pedig nem képes kiírni a saját típusainkat, valamint ezt megtanítani sem tudjuk neki.</p>
<h2 id="c-alternatívák"><a class="header" href="#c-alternatívák">C++ alternatívák</a></h2>
<p><a href="https://en.cppreference.com/w/cpp/io/cout">https://en.cppreference.com/w/cpp/io/cout</a></p>
<p><a href="https://en.cppreference.com/w/cpp/io/cin">https://en.cppreference.com/w/cpp/io/cin</a></p>
<p>C++ban a standard input és output két fő globális objektum(<code>std::cin</code> és <code>std::cout</code>) és a C-ből shiftelő operátorokként(<code>&gt;&gt;</code> és <code>&lt;&lt;</code>) ismert szimbólumokkal lett megoldva. A standard IO használatához az <code>iostream</code> headerre van szükség.</p>
<p>Ha egy változóba szeretnénk beolvasni, majd ezt kiírni:</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

int main(){
    int x;
    std::cin &gt;&gt; x;
    std::cout &lt;&lt; x;
}

</code></pre>
<p>A beolvasásokat és kiírásokat láncolhatjuk is:</p>
<pre><code class="language-cpp">int x;
double d;
char c;

std::cin &gt;&gt; x &gt;&gt; d &gt;&gt; c;
std::cout &lt;&lt; "int: " &lt;&lt; x &lt;&lt; " double: " &lt;&lt; d &lt;&lt; " char: " &lt;&lt; c;
</code></pre>
<p>Ez a "szintaktika" operátorok túltöltésén(overload) alapul.
Jelenleg annyi említest teszek ezzel kapcsolatban, hogy valójában egy <code>operator&lt;&lt;</code> függvényt hívunk meg az <code>std::cout</code>(referencia rá) és a "kiírandó dolog" paraméterekkel, ami aztán referenciaként újra visszaadja az <code>std::cout</code> -ot, így tudjuk őket láncolni is.
Később azt is megtanuljuk, hogy pontosan hogyan működik az operátorok overload-olása és láncolása, valamint megtanítjuk majd a saját típusaink beolvasását és kiírását is.</p>
<h3 id="get"><a class="header" href="#get">Get</a></h3>
<p><a href="https://en.cppreference.com/w/cpp/io/basic_istream/get">https://en.cppreference.com/w/cpp/io/basic_istream/get</a></p>
<pre><code class="language-cpp">char k = std::cin.get(); //bekérünk 1 karaktert

char k2;
std::cin.get(k2); //ugyanaz mint az előző, csak máshogy, itt out parameter van return helyett

char k3[6];
std::cin.get(k3, 5); //5 karaktert olvasunk egy 5 méretű tömbbe. Ez a függvény tesz lezáró 0-t

</code></pre>
<h2 id="stdgetline"><a class="header" href="#stdgetline">std::getline</a></h2>
<p><a href="https://en.cppreference.com/w/cpp/string/basic_string/getline">https://en.cppreference.com/w/cpp/string/basic_string/getline</a>
Az std::getline függvény alapértelmezetten egy egész sort olvas be egy input streamről, viszont saját elválasztót is megadhatunk neki.</p>
<pre><code class="language-cpp">std::string line;
std::getline(std::cin, line);
std::getline(std::cin, line, ','); // ',' karakterig olvasunk
</code></pre>
<h2 id="ignore"><a class="header" href="#ignore">Ignore</a></h2>
<p><a href="https://en.cppreference.com/w/cpp/io/basic_istream/ignore">https://en.cppreference.com/w/cpp/io/basic_istream/ignore</a></p>
<p>A bemeneti streameknek van egy <code>ignore</code> tagfüggvénye, amellyel eldobhatunk("ignorálhatunk") karaktereket.</p>
<pre><code class="language-cpp">std::cin.ignore(x); // x karaktert ignorál, vagy amíg eof-t nem kap
std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max()); //ignorál mindent ami a bemeneten van
std::cin.ignore(x, c); //ignorál x karakter, vagy amíg nem kap c-vel azonos karaktert
</code></pre>
<p><code>std::numeric_limits&lt;T&gt;::max()</code> : adott <code>T</code> típusú numerikus típus maximum értékét adja vissza. (pl. <code>std::numeric_limits&lt;std::size_t&gt;::max()</code>)</p>
<p>Pl:</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;limits&gt;

int main(){
    int a;
    int b;
    std::cin &gt;&gt; a;
    std::cin.ignore(5);
    std::cin &gt;&gt; b;
    std::cout &lt;&lt; "a: " &lt;&lt; a &lt;&lt; " b: " &lt;&lt; b &lt;&lt; '\n';

    char c1;
    char c2;
    std::cin &gt;&gt; c1;
    //ignorálunk addig amíg ';' -t nem kapunk. Ignorálja a ; -t is!
    std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), ';'); 
    std::cin &gt;&gt; c2;
    std::cout &lt;&lt; "c1: '" &lt;&lt; c1 &lt;&lt;"' c2: '" &lt;&lt; c2 &lt;&lt; "'\n";
}
</code></pre>
<p><img src="Screenshot%202025-01-29%20115519.png" alt="" /></p>
<p><em>Nem összekeverendő a teljesen más jelentésű <code>std::ignore</code>-al.</em></p>
<h2 id="file-io"><a class="header" href="#file-io">File IO</a></h2>
<p>C++ -ban a file IO <em>API</em>-ja(az, amit a programozó lát belőle, Application Programming Interface) megegyezik a standard IO-val.</p>
<p>File olvasásra megnyitásához  és nyilvántartásához az <code>std::ifstream</code> (Input Filestream) típust, írásra az <code>std::ofstream</code> (Output Filestream) típust használjuk.</p>
<pre><code class="language-cpp">#include &lt;fstream&gt;

int main(){
    std::ifstream input("input.txt");
    int x;
    input &gt;&gt; x; 
    std::ofstream output("output.txt");
    output &lt;&lt; x;
}
</code></pre>
<p>Az <code>std::ifstream</code> és <code>std::ofstream</code> típusó objektumok automatikusan(ld. <a href="./5-oszt%C3%A1lyok.html">osztályok</a>) bezárják a fileokat, ha scopeon kívül kerülnek, így nem szükséges a fileokat manuálisan bezárni, viszont a lehetőségünk megvan rá. (<code>.close()</code>)</p>
<h2 id="io-manipulátorok"><a class="header" href="#io-manipulátorok">IO manipulátorok</a></h2>
<p>Az IO műveletek viselkesését ún. manipulátorok segítségével változtathatjuk meg. Ezeket úgy használjuk, mintha ők maguk is input/output lennének. Pl. ha az egészeket mindenképp 7 számjeggyel szeretnénk kiírni, és 0-val kitölteni a maradék helyet.</p>
<pre><code class="language-cpp">#include &lt;iomanip&gt;
#include &lt;iostream&gt;

int main(){
    int x = 356463;
    std::cout &lt;&lt; std::setw(7) &lt;&lt; std::setfill('0') &lt;&lt; x; 
}
</code></pre>
<p>A manipulátorok hatóköre változó, vannak olyanok, amelyek csak a következő outputra hatnak, de vannak olyanok is, amelyek hatása "végtelen"(amíg meg nem változtatjuk).</p>
<p>Fontosabb mainpulátorok:</p>
<ul>
<li><code>std::setw(size)</code> : megadja, hogy a kiírt számok hány karakter szélesek legyene</li>
<li><code>std::setfill(ch)</code> : a paraméterként kapott karakterrel lesz kitöltve a maradék hely, ha egy kiírt érték nem tölti ki a megadott szélességet</li>
<li><code>std::setprecision(p)</code> : a lebegőpontos számok tizedesjegyeinek pontosságát(számát) állítja be</li>
</ul>
<p>Több IO manipulátor és egyéb kapcsolódó foszlányok itt: <a href="https://en.cppreference.com/w/cpp/io/manip">https://en.cppreference.com/w/cpp/io/manip</a></p>
<p>Sokszor állítunk el dolgokat egy IO streamen, viszont nem szeretnénk egyesével visszaállítani az eredeti értékeket.
Ekkor van két lehetőségünk.
Az első, hogy egy "buffer stream" segítségével összeállítunk egy stringet és ezt a stringet írjuk ki. Ehhez használjuk az <code>std::stringstream</code> típust: <a href="https://en.cppreference.com/w/cpp/io/basic_stringstream">https://en.cppreference.com/w/cpp/io/basic_stringstream</a></p>
<p><a href="https://godbolt.org/z/59YETh5dn">https://godbolt.org/z/59YETh5dn</a></p>
<pre><code class="language-cpp">#include &lt;sstream&gt;
#include &lt;iostream&gt;

int main(){
    std::stringstream buf;
    buf &lt;&lt; std::hex &lt;&lt; 45678;
    std::cout &lt;&lt; buf.str();
}
</code></pre>
<p>A másik lehetőség az, hogy a stream beállításait(flag, precision, width) elmentjük, majd ezeket visszaállítjuk. Ez elég nagy szenvedés és nem érdemes csinálni, csak ha nagyon muszály.</p>
<p><a href="https://godbolt.org/z/o1hxqvnzz">https://godbolt.org/z/o1hxqvnzz</a></p>
<pre><code class="language-cpp">#include &lt;sstream&gt;
#include &lt;iostream&gt;
#include &lt;iomanip&gt;

int main(){
    //most őszintén, kinek van ehhez kedve?
    std::ios_base::fmtflags flags = std::cout.flags();
    std::streamsize prec = std::cout.precision();
    std::streamsize width = std::cout.width();
    std::cout &lt;&lt; std::hex &lt;&lt; 465643 &lt;&lt; std::setprecision(12) &lt;&lt; std::setw(20) &lt;&lt; 454.3256456436;
    std::cout.flags(flags);
    std::cout.precision(prec);
    std::cout.width(width);
    std::cout &lt;&lt; '\n';
    std::cout &lt;&lt; 54;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kivételek-hibakezelés"><a class="header" href="#kivételek-hibakezelés">Kivételek, hibakezelés</a></h1>
<h2 id="hibakezelés-c-ben"><a class="header" href="#hibakezelés-c-ben">Hibakezelés C-ben</a></h2>
<pre><code class="language-c">
double oszt(double x, double y){
    if(y == 0){
        //mit csináljunk? exit, vagy csak írjunk ki valamit? 
    }else{
        return x/y;
    }
}
</code></pre>
<h2 id="c--ban"><a class="header" href="#c--ban">C++ -ban</a></h2>
<p><a href="https://en.cppreference.com/w/cpp/language/exceptions">https://en.cppreference.com/w/cpp/language/exceptions</a></p>
<p>A C++ egy fontos nyelvi elemei a kivételek(exception). Ezek segítségével <em>kivétel</em>es esetekkor dobhatunk egy "hibát", amit a program elkaphat. Ez egy megosztó feature a közösségben(ld. "hidden control flow"), viszont sokszor hasznos lehet. Például nullával való osztás esetén valószínűleg nem nekünk, hanem a hívó kódnak kéne kezelnie a hibát.</p>
<p>Kivételt a <code>throw</code> kulcsszóval dobhatunk, valamint a <code>try</code> kulcsszóval nyitott scope-ban dobott kivételeket a <code>catch</code> kulcsszóval kaphatunk el.</p>
<p>Kivételként bármilyen típust dobhatunk(int, const char*, stb.), viszont érdemes az <code>std::exception</code> és a belőle leszármazó(később) típusú objekutmokat dobni. Ezekhez a típusokhoz az <code>stdexcept</code> nevű header-re van szükség.</p>
<p><a href="https://en.cppreference.com/w/cpp/error/exception">https://en.cppreference.com/w/cpp/error/exception</a></p>
<p><a href="https://godbolt.org/z/axWfMGxxK">https://godbolt.org/z/axWfMGxxK</a></p>
<pre><code class="language-cpp">#include &lt;stdexcept&gt;
#include &lt;iostream&gt;

double oszt(double x, double y){
    if(y == 0){
        throw std::runtime_error("0-val valo osztas!"); 
        /*
        lehetne:
        throw "0-val valo osztas";
        vagy
        throw 0;
        stb. viszont ezeket nem szép dobni.
        */
    }else{
        return x/y;
    }
}

int main(){
    try{
        oszt(5.0, 0.0);
    }catch(const std::exception&amp; e){ //konstans referenciaként kapjuk el az exception-t(ezt mindig!)
        std::cout &lt;&lt; e.what(); //.what() : visszaadja az exception "üzenetét"
        //egyéb hibakezelő kód...
    }
}
</code></pre>
<p>Később lesz szó arról, hogy hogyan készíthetünk saját kivétel típusokat amelyek az <code>std::exception</code> -ből származnak.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dinamikus-memóriakezelés"><a class="header" href="#dinamikus-memóriakezelés">Dinamikus memóriakezelés</a></h1>
<h2 id="c-dinamikus-memóriakezelés"><a class="header" href="#c-dinamikus-memóriakezelés">C dinamikus memóriakezelés</a></h2>
<p>A C dinamikus memóriakezelése a kőkorszakban jár. Megkérdezi hány bájtnyi memóriára van szükségünk, majd visszadob rá egy pointert.</p>
<h2 id="c-memóriakezelés"><a class="header" href="#c-memóriakezelés">C++ memóriakezelés</a></h2>
<p>A C++ <code>malloc</code> függvényét a <code>new</code> operátor(igen, ezek operátorok), a <code>free</code> függvényt pedig a <code>delete</code> és <code>delete[]</code> operátor váltotta fel.</p>
<p>A <code>new</code> egy intelligens eszköz. Nem memóriamennyiséget, hanem egy típust és opcionálisan egy tömbméretet kap.
Pl.</p>
<pre><code class="language-cpp">
int* x = new int; //egy darab dinamikusan foglalt int

int* tomb = new int[5]; //egy dinamikusan foglalt 5 méretű tömb

std::size_t tombMeret; //std::size_t : általában memóriafoglalások méretét vagy indexeket tároló előjel nélküli egész

std::cin &gt;&gt; tombMeret;

int* dinTomb = new int[tombMeret];
</code></pre>
<p>A <code>delete</code> operátor a <code>new</code> operátorral lefoglalt memóriát szabadítja fel. Ha tömböt szabadítunk fel, akkor a <code>delete[]</code> operátort kell használni.</p>
<p>Az előbbi példa foglalások felszabadítása:</p>
<pre><code class="language-cpp">delete x;
delete[] tomb;
delete[] dinTomb;
</code></pre>
<h2 id="variable-length-array"><a class="header" href="#variable-length-array">Variable Length Array</a></h2>
<p>Az alábbi kódrészlet az ISO C++ Standard szerint nem szabványos C++, a GCC és Clang fordítók compiler extensionként engedélyezik. VLA-t ne használjunk, hiszen így a stacken szükséges memória mérete ismeretlen lesz.</p>
<p><a href="https://godbolt.org/z/93xxj5WPM">https://godbolt.org/z/93xxj5WPM</a></p>
<pre><code class="language-cpp">int x;
std::cin &gt;&gt; x;
int a[x];
</code></pre>
<p><em>A non-standard extension-ök kikapcsolása:</em></p>
<ul>
<li>GCC/Clang: <code>-pedantic-errors</code> flag</li>
<li>MSVC: <code>/fpermissive-</code> flag</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sablonok-template"><a class="header" href="#sablonok-template">Sablonok (template)</a></h1>
<h2 id="sablon-alapok"><a class="header" href="#sablon-alapok">Sablon alapok</a></h2>
<p>A C++ egyik legnagyobb előnye a C-vel szemben a generikus programozási lehetőségekben rejlik. A jegyzetben már szerepelt az alábbi függvény:</p>
<p><a href="https://godbolt.org/z/86ae5adTr">https://godbolt.org/z/86ae5adTr</a></p>
<pre><code class="language-cpp">//swap C++ -ban
void cpp_swap(int&amp; x, int&amp; y){
    int tmp = x;
    x = y;
    y = tmp;
}
</code></pre>
<p>Ezt a függvényt szeretnénk megírni, hogy működjön mindenféle típusra. Természetesen ez lehetetlen küldetésnek tűnhet, azonban a C++ templatek fő felhasználási módja éppen ez.</p>
<p><a href="https://godbolt.org/z/rrzMjYvK7">https://godbolt.org/z/rrzMjYvK7</a></p>
<pre><code class="language-cpp">template &lt;typename T&gt; //sablondeklaráció, sablonparaméterek(itt T) felsorolása
void cpp_swap(T&amp; x, T&amp;y){ //cpp_swap&lt;T&gt; függvénysablon
    T tmp = x;
    x = y;
    y = tmp;
}
</code></pre>
<p>A fent látható <code>cpp_swap</code> -ot <em>függvénysablon</em>nak hívjuk. Önmagában nem függvény, ahhoz "példányosítani" kell. Ez a gyakorlatban annyit jelent, hogy használjuk.</p>
<p>pl.</p>
<pre><code class="language-cpp">int main(){
    int x = 6;
    int y = 2;

    // cpp_swap&lt;T&gt; függvénysablon példányosítása T=int sablonparaméterekkel
    cpp_swap&lt;int&gt;(x, y); //&lt;int&gt; &lt;- sablonparaméter megadása

    std::cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; '\n';

    float a = 7.3;
    float b = 1.2;
    cpp_swap&lt;float&gt;(a, b);
    std::cout &lt;&lt; a &lt;&lt; ' ' &lt;&lt; b;
}
</code></pre>
<p>Amikor egy sablont példányosítunk adott sablonparaméterekkel, olyankor valójában fordításidőben kód generálódik az adott sablonparaméterek behelyettesítésével.
Pl.</p>
<pre><code class="language-cpp">cpp_swap&lt;int&gt;(x, y); //cpp_swap&lt;T&gt; függvénysablon példányosítása T=int sablonparaméterekkel
</code></pre>
<p>esetén a</p>
<pre><code class="language-cpp">void cpp_swap(int&amp; x, int&amp; y){ 
    int tmp = x;
    x = y;
    y = tmp;
}
</code></pre>
<p>kód generálódik. A <code>T</code> helyére mindenhol <code>int</code> kerül. Ezt a generált kódot nekük természetesen nem kell látnunk, vagy foglalkoznunk vele.</p>
<p>A sablonparamétereket a fordító néha le tudja vezetni a kapott függvényparaméterekből(template parameter deduction).
Például:</p>
<pre><code class="language-cpp">double a = 5.2;
double b = 1.2;
cpp_swap(a, b); //nem kell megadni, hogy double típus, mivel a és b double típusúak

cpp_swap&lt;double&gt;(a, x); //meg kell adni, hogy double típus, mivel a és x különböző típusúak, így a fordító nem tud dönteni
</code></pre>
<p>A sablonok(template) használata nagyon elterjedt a C++ programozásban, ezért néhány standard library implementáció gyakran Standard Template Library(STL) -nek nevezi magát(pl. MSVC STL, EA Games STL).</p>
<h2 id="duck-typing"><a class="header" href="#duck-typing">Duck typing</a></h2>
<p>A sablonokkal felmerül egy újabb kérdés: milyen típusokat fogadunk el? A válasz erre egyszerű: mindent, amivel a függvény kódja lefordul.</p>
<p>Ezt "duck typing" -nak hívjuk: <em>"If it walks like a duck and it quacks like a duck, then it must be a duck"</em></p>
<p>Például nézzünk meg egy függvényt, ami megmondja két <em>valamiről</em>, hogy az első <em>valami</em> nagyobb-e, mint a második <em>valami</em>.</p>
<pre><code class="language-cpp">template&lt;typename T&gt;
bool nagyobbe(T elso, T masodik){
    return elso &gt; masodik;
}
</code></pre>
<p>Milyen típusokra működik ez a függvény?
Hát azokra, amelyek ezeket a feltételeket teljesítik:</p>
<ul>
<li>lemásolhatók (hiszen másolatként vesszük át őket)</li>
<li>összehasonlíthatók a <code>&gt;</code> operátorral</li>
</ul>
<p><em>Vegyük észre</em>: ezek pontosan azok a feltételek, amelyek ahhoz kellenek, hogy a kódban az adott típust T helyére beillesztve a kód leforduljon.</p>
<p>A sablonok korlátozására léteznek további technikák(SFINAE, concept), azonban ezek messze túlmutatnak a tárgy anyagán.</p>
<h2 id="nem-típus-sablonparaméterek-nem-függvény-sablonok"><a class="header" href="#nem-típus-sablonparaméterek-nem-függvény-sablonok">Nem-típus sablonparaméterek, nem-függvény sablonok</a></h2>
<p>Sablonparaméterként átadható nem csak típus, hanem gyakorlatilag bármilyen más objektum is. Pl. a standard library egy típusa az <code>std::array</code>, amely első függvényparamétere a tömbben tárolt típus, második függvényparamétere egy pozitív egész szám, a tömb mérete.</p>
<pre><code class="language-cpp">std::array&lt;int, 5&gt; tomb; //5 méretű int-eket tároló tömb
</code></pre>
<p>Ezt kódban a következőként "replikálhatjuk":</p>
<pre><code class="language-cpp">template&lt;typename T, std::size_t siz&gt;
struct array{ // array&lt;T, siz&gt; "osztálysablon"(osztályok később)
    T belso_tomb[siz];
    //array implementáció...
};

template &lt;int N&gt;
void print_template_int(){
    std::cout &lt;&lt; N &lt;&lt; '\n';
}
</code></pre>
<p>Fontos azt megjegyezni, hogy a sablonok fordításidőben példanyosodnak, szóval minden sablonparaméternek fordításidőben konstansnak kell lennie.
pl.</p>
<pre><code class="language-cpp">print_template_int&lt;5&gt;(); //ok
int x = 5;
print_template_int&lt;x&gt;(); //hiba, x nem fordításidejű konstans(const int x sem oldaná meg)
</code></pre>
<h2 id="részleges-specializáció"><a class="header" href="#részleges-specializáció">Részleges specializáció</a></h2>
<p>Tegyük fel, hogy szeretnénk ha egy adott sablon egy speciális módon működjön, ha egy adott típust kap.
Például ha a swap függvényünk int-et kap, akkor írja ki, hogy "int", különben működjön normális módon.</p>
<p><a href="https://godbolt.org/z/zj1bfe5s9">https://godbolt.org/z/zj1bfe5s9</a></p>
<pre><code class="language-cpp">template &lt;typename T&gt; 
void cpp_swap(T&amp; x, T&amp;y){ 
    T tmp = x;
    x = y;
    y = tmp;
}

template &lt;&gt; 
void cpp_swap&lt;int&gt;(int&amp; x, int&amp;y){ //specializáció a T=int esetre
    std::cout &lt;&lt; "int ";
    int tmp = x;
    x = y;
    y = tmp;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="osztályok-objektumok"><a class="header" href="#osztályok-objektumok">Osztályok, objektumok</a></h1>
<p><em>most ugrik a majom a vízbe</em></p>
<p><strong>Ez egy viszonylag hosszú fejezet, azonban a nyelv megértéséhez esszenciális!</strong></p>
<h2 id="osztály-objektum"><a class="header" href="#osztály-objektum">Osztály, objektum</a></h2>
<p>A C nyelvben már megismerhettük a <code>struct</code> kulcsszót, ami azonos dologhoz tartozó adatokat tárolt. Valószínűleg sok olyan függvényt írtunk ekkor, hogy</p>
<pre><code class="language-c">struct foo {};

void foo_szamol(struct foo f) {}
</code></pre>
<p>és társai. Jó lenne, ha a <code>foo_szamol</code> függvényt valahogyan a <code>foo</code> struktúrához köthetnénk.</p>
<p>Az osztályok ezt a problémát oldják meg, valamint néhány nagyon hasznos utility-t adnak a programozó kezébe.</p>
<p>Egy osztályt a <code>class</code> vagy a <code>struct</code> kulcsszóval(különbség később) tudunk definiálni, <code>typedef</code> használatára egyáltalán nincs szükség.</p>
<p>Egy osztályból "példányokat" hozhatunk létre, ez gyakorlatilag azt jelenti, hogy az adott osztály típusú változót hozunk létre a C struktúrákhoz hasonlóan.</p>
<pre><code class="language-cpp">class Foo {};

int main(){
    Foo f;
}
</code></pre>
<h2 id="publikus-és-privát-elérés"><a class="header" href="#publikus-és-privát-elérés">Publikus és privát elérés</a></h2>
<p>Egy osztály tartalmazhat "member"-eket(tagokat), amelyeknek különböző láthatóságai lehetnek.
Ezt a <code>public</code>, <code>private</code> és <code>protected</code> (később) szavakkal állíthatjuk be. Ezeket a kulcsszavakat <em>access specifier</em>-nek hívjuk.
A privát tagokat csak az osztályon belülről, a public-okat kívülről is elérhetjük. Egy osztályban alapból minden private, amíg ezt meg nem változtatjuk.</p>
<p><a href="https://godbolt.org/z/vYb75s41a">https://godbolt.org/z/vYb75s41a</a></p>
<pre><code class="language-cpp">class Foo {
public: //ez után a következő access-specifier -ig minden public.
    int x;
private: //ez után a következő access-specifier -ig minden private.
    double y;
};

int main(){
    Foo f;
    f.x = 5;
    f.y = 2.3; //nem ok, y private
</code></pre>
<h2 id="tagfüggvények-member-functions"><a class="header" href="#tagfüggvények-member-functions">Tagfüggvények (member functions)</a></h2>
<p>Az osztályok egyik "breaktrough" feature-je, hogy függvényeket tartalmazhatnak, amelyek az osztály által tárolt állapoton(state) operálnak.</p>
<p>Egy tagváltozó lehet <code>const</code>, ami azt jelenti, hogy nem változtatja meg az objektum állapotát, így <code>const</code> objektumon is működik.<br>
<em><strong>FONTOS</strong></em> egy tagfüggvény túltölthető az alapján, hogy <code>const</code> -e, vagy nem, így a <code>const</code> qualifier része a függvény fejlécének! (signature)</p>
<p>A <code>this</code> pointer egy osztályon belül az adott példányra vonatkozik, viszont kiírni csak akkor kell, ha egy tagfüggvény paramétere miatt egy név nem egyértelmű.
A tagfüggvények gyakorlatilag speciális függvények, amelyek első paramétere a rejtett <code>this</code> pointer.</p>
<p>A szintaxis a következő:</p>
<p><a href="https://godbolt.org/z/E3YP9scPq">https://godbolt.org/z/E3YP9scPq</a></p>
<pre><code class="language-cpp">class Square{
private:
    double side_length; //privát, írunk rá publikus set és get függvényt.

public:
    //"Setter" függvény, nagyon hasznos ha nem triviális egy érték beállítása(pl. itt side_length &gt; 0 check miatt)
    void set_side_length(double side_length){
        if(side_length &lt;= 0) { 
            throw std::runtime_error("side length &lt;= 0 is not allowed");
        }

    //this-&gt;side_length: az adott példány oldalhossza,
    //side_length: a tagfüggvény paramétere
        this-&gt;side_length = side_length; 
    }

    double get_side_length() const { //const, mivel nem változtatja a példányt.
        return side_length; //nem kell this-&gt; mivel nincs név konfliktus.
    }

    double calculate_area() const { //const, mivel csak számol, ez sem változtat semmit
        return side_length * side_length;
    }
};
</code></pre>
<p>Tagfüggvényeket a <code>.</code> operátorral érhetünk el:</p>
<pre><code class="language-cpp">int main(){
    Square square;
    square.set_side_length(2.5);
    std::cout &lt;&lt; square.calculate_area();
}
</code></pre>
<p>Felfedezhetjük azonban azt a problémát, hogy egy <code>const</code> négyzet objektummal sok mindent nem tudunk kezdeni, ugyanis annak nem változtathatjuk meg az oldalhosszát, mután az objektum "elkészült". Ezt a problémát később, a konstruktorral oldjuk meg.</p>
<h2 id="konstruktor-destruktor-és-raii"><a class="header" href="#konstruktor-destruktor-és-raii">Konstruktor, destruktor és RAII</a></h2>
<p>Most jön talán a C++ legfontosabb része. A RAII(Resource Acquisition Is Initialization), de hívhatjuk <em>"Scope Based Resource Management</em>-nek is, módszer szerint egy objektum élettartama kezdetén(construction) átveszi és lefoglalja a számára szükséges erőforrásokat(memória, adatbázishoz csatlakozás, stb.) és élettartama végén(destruction) felszabadítja, bezárja ezeket az erőforrásokat.</p>
<p>A C++ nyelvben a "konstruktor"(constructor, ctor) speciális tagfüggvény fut az objektum élettartamának kezdetekor, és a destruktor fut az élettartam legvégén. Erre nézzünk egy egyszerű példát.</p>
<p>A konstruktornak és destruktornak nincs visszatérési értéke. A konstruktor függvény neve mindig megegyezik az osztály nevével, a destruktor neve pedig <code>~osztaly_neve</code>.
Objektum létrehozása alatt azt értjük, amikor egy lokális változót definiálunk az adott osztálytípussal, vagy a <code>new</code> operátorral dinamikus élettartamú objektumot hozunk létre.
Lokális változó élettartama a definiálásától a scope végéig, dinamikus élettartamú objektum élettartama a lefoglalásától(<code>new</code>) a felszabadításáig(<code>delete</code>) tart.</p>
<pre><code class="language-cpp">class Foo{
    Foo() {
        std::cout &lt;&lt; "Foo ctor\n";
    }

    ~Foo() {
        std::cout &lt;&lt; "Foo dtor\n";
    }
};

int main(){
    Foo f; //foo ctor lefut
    /*
    ...
    */

    return 0; //foo dtor lefut
}
</code></pre>
<p>Azt a konstruktort, amely paraméter nélkül hívható, <em>defualt konstruktor</em>nak nevezzük. Ha egy osztályban minden tagváltozónak van default konstruktora, és mi nem írtunk külön konstruktort, akkor az osztálynak generálódik default konstruktor.</p>
<p>Egy osztályból csak akkor hozható létre (C értelemben vett) tömb, ha annak van default konstruktora.</p>
<p>A konstruktor arra való, hogy egy példány alap értékeit beállítsuk, viszont a konstruktorba írt kód valójában az objektum létrejötte után fut, így pl. konstans tagváltozókat, vagy konstans objektum tagváltozóit nem tudunk beállítani itt, ezért a tagváltozók inicializálását általában a "member initialization list" -en tesszük meg. Ennek kicsit furcsa szintaxisa van: <code>classname() : member1(value1), member2(value2)</code><br>
Vegyük újra példának a <code>Square</code> osztályt.</p>
<p><a href="https://godbolt.org/z/hK479jPbY">https://godbolt.org/z/hK479jPbY</a></p>
<pre><code class="language-cpp">class Square{
private:
    double side_length; //privát, írunk rá publikus set és get függvényt.
    std::string name; //std::string : egy dinamikusan növő karakter tömb, modern nyelvektől elvárt string típus
public:
    // : side_length(side_length) -&gt; a side_length nevű tagváltozót inicializáljuk a side_length nevű paraméterrel
    // vesszővel választjuk el a tagokat
    Square(double side_length, const std::string&amp; name) : side_length(side_length), name(name) {
    } //így már lehet const Square is használható objektum

    //"Setter" függvény, nagyon hasznos ha nem triviális egy érték beállítása(pl. itt side_length &gt; 0 check miatt)
    void set_side_length(double side_length){
        if(side_length &lt;= 0) { 
            throw std::runtime_error("side length &lt;= 0 is not allowed");
        }

        this-&gt;side_length = side_length; //this-&gt;side_length: az adott példány oldalhossza, side_length: a tagfüggvény paramétere
    }

    double get_side_length() const { //const, mivel nem változtatja a példányt.
        return side_length; //nem kell this-&gt; mivel nincs név konfliktus.
    }
};

int main(){
    Square square(5.3, "foo"); //konstruktor hívás
    Square square; //ez most nem működik, mert Square-nek nincs default konstruktora. 
}
</code></pre>
<h2 id="osztálysablonok"><a class="header" href="#osztálysablonok">Osztálysablonok</a></h2>
<p>Mint ahogyan a függvények, az osztályokhoz is lehet sablonokat készítnei.
pl.</p>
<pre><code class="language-cpp">template &lt;typename T&gt;
class Foo{
public:
    T x;
};
</code></pre>
<p>Nagyon hasonlóan működik a függvényparaméterekhez, szimpla kódgenerálásról van szó.</p>
<h2 id="gyakori-félreértések-static-tagfüggvények"><a class="header" href="#gyakori-félreértések-static-tagfüggvények">Gyakori félreértések, static tagfüggvények</a></h2>
<p><em>adatbázisok referencia következik</em>
Amikor egy osztályt hozunk létre, azzal még nem jön létre objektum. Az osztály egy tervrajz, egy <em>valami</em> leírása. Ez az objektumorientált programozás alapelve. A való világ(vagy esetleg kitalált világ) dolgairól készült tervrajzokból hozunk létre <em>példányokat</em>. Egy osztály egy példányát nevezzük általában objektumnak.</p>
<p>Pl.</p>
<pre><code class="language-cpp">class foo{};

int main(){
    foo f; // f a foo osztály egy példánya
}
</code></pre>
<p>Amikor egy osztályban egy tagváltozót érünk el, az az adott példány tagváltozójára vonatkozik. Emlékezzünk vissza, a tagváltozók elérése (még ha implicit módon is) a <code>this</code> pointeren keresztül történik, azaz a példányunkra mutató pointeren keresztül.</p>
<p>Vannak azonban esetek amikor valamilyen állapotot nem egy példányhoz, hanem az osztályhoz szeretnénk kötni. Nos erre való a <code>static</code> kulcsszó. Egy statikus tagváltozó nem a példányokhoz, hanem az osztályhoz tartozik, a statikus tagfüggvény ugyanígy az osztályhoz tartozik. Természetesen ez azt is jelenti, hogy statikus tagváltozót/tagfüggvényt nem érhetünk el példányon keresztül, valamint <code>non static</code> tagváltozókat és tagfüggvényeket nem érhetünk el statikus tagfüggvényekből.</p>
<p>Statikus tagváltozókat a <code>::</code> operátorral érhetünk el:
<code>foo::bar();</code></p>
<pre><code class="language-cpp">class foo{
    public:
        static void s_bar() {}
        void m_bar() {}
        int s_x;
        int m_x;
};

int main(){
    foo f;
    f.m_bar(); //ok
    f.m_x = 4; //ok
    f.s_bar; //nem ok
    foo::s_bar(); //ok
}
</code></pre>
<h2 id="egyetlen-felelősség-elve"><a class="header" href="#egyetlen-felelősség-elve">Egyetlen felelősség elve</a></h2>
<p><em>"A module should be responsible to one, and only one, actor."</em> <br>
Nos ez egy kicsit furcsa lehet, szóval vegyünk egy érthetőbb megfogalmazást:
Egy osztálynak egyetlen felelősséget kell lefednie, viszont azt teljes mértékben.</p>
<p>Pl. A <code>string</code> osztályunk kezeli a dinamikus karaktertömböt, viszont azzal nem foglalkozik, hogy a karaktereit egyesével hogy írjuk ki.</p>
<h2 id="komolyabb-raii-példa"><a class="header" href="#komolyabb-raii-példa">Komolyabb RAII példa</a></h2>
<p>Most pedig nézzünk egy komolyabb RAII példát.
A tervünk egy dinamikusan növő tömb osztálysablon létrehozása ami bármilyen lemásolható típust képes tárolni.
Ezt a példát sokáig fogjuk használni.</p>
<p>Szóval szükségünk lesz egy <code>typename T</code> sablonparaméterre, egy pointerre, ami a tömbre mutat, valamint tárolni kell a tömb méretét</p>
<pre><code class="language-cpp">#include &lt;cstdint&gt;

template &lt;typename T&gt;
class DinTomb{
    T* tomb; //pointer a dinamikus tömbre
    std::size_t meret; //a dinamikus tömb mérete

public:
    /**
     * @brief Default konstruktor, mindent 0-ra inicializál
     */
    DinTomb() : tomb(nullptr), meret(0) {}

    /**
     * @brief hozzáad egy új elemet a tömb végéhez. Nagyon hasonlít a C-ben megismert algoritmushoz, csak malloc-free helyett new-delete[] van
     * @param elem az elem amit hozzáadunk(lemásolható kell, hogy legyen)
     */
    void push_back(const T&amp; elem) {
        T* uj_tomb = new T[meret + 1];
        for(std::size_t i = 0; i &lt; meret; ++i){
            uj_tomb[i] = tomb[i];
        }
        uj_tomb[meret] = elem;
        delete[] tomb; // delete[], mert tömböt szabadítunk fel.
        tomb = uj_tomb;
        ++meret;
    }

    std::size_t size() const { return meret; }

    /**
     * @brief indexelő függvény
     * @param idx
     * @return referencia az adott indexen lévő elemre
     * @throw std::out_of_range, ha túlindexelés történik
     */
    T&amp; at(std::size_t idx) {
        if(idx &gt;= meret) {
            throw std::out_of_range("Tomb tulindexelve!");
        }
        return tomb[idx];
    }

    //ua. mint az előbb, csak konstans verzió
    const T&amp; at(std::size_t idx) const { 
        if(idx &gt;= meret) {
            throw std::out_of_range("Tomb tulindexelve!");
        }
        return tomb[idx];
    }

    ~DinTomb() {
        delete[] tomb; //destruktor felszabadítja a lefoglalt memóriát
    }
};

int main(){
    DinTomb&lt;double&gt; tomb; //valos szamokat tartalmazo dinamikus tomb

    tomb.push_back(4.3);
    tomb.push_back(3.2);
    tomb.at(0) = 5.8; //függvény az egyenlőség bal oldalán, mivel referenciát ad vissza!
    return 0; // nem kell semmi manuális memóriakezelés, mert a destruktor automatikusan felszabadítja amit kell, mert egyszer megírtuk
}
</code></pre>
<p>Nos igen, ez a RAII lényege. Nem kell manuálisan sehol <code>delete</code> és <code>new</code> -t írnunk, ha szépen becsomagoltuk a memóriakezelést egy osztályba. Az erőforráskezelést elabsztraktáltuk a felsőbb szintű kód elől, így ezt a tömb osztályt használva már nem kell a memóriakezeléssel foglalkoznunk.</p>
<p>Jó RAII példák a már megismert filestream osztályok. A konstruktorukban megnyitják a filet(elkérik a file handle-t az OS-től), majd a destruktorukban automatikusan bezárják a file-t.</p>
<h2 id="objektumok-másolása"><a class="header" href="#objektumok-másolása">Objektumok másolása</a></h2>
<p>Tegyük fel, hogy a tömbünkből másolatot szeretnénk csinálni. Ez valójában nem más, mint egy tömbből egy új tömböt csinálunk. Azt a konstruktort, amely egy <code>T</code> típusú objektumból <code>T</code> típusú objektumot készít <em>másoló konstruktor</em>(copy constructor)-nak nevezzük.</p>
<p>A copy constructor valójában azt mondja meg, hogyan is kéne lemásolni egy objektumot. Ez sok esetben triviális, pl.</p>
<pre><code class="language-cpp">class foo{
    public:
        int x;
        float y;
        double t;
};
</code></pre>
<p>Ha egy osztálynak minden tagváltozója lemásolható(van copy constructora, vagy pl. primitív típus), akkor lesz automatikusan generált copy constructora is.</p>
<p>A copy constructor paramétereként <code>const T&amp;</code> -et vesz át. Persze, hiszen a másolandó objektumot nem változtatjuk és a nem referenciaként átvételhet(lemásolásához) copy constructorra lenne szükség.
Ha például az osztályunk egy dinamikusan növő tömböt kezel, nem másolhatjuk le egyszerűen a tömbre mutató pointert, hanem a tömböt elemenként le kell másolni(deep copy).
Ennek oka az, hogy a pointer lemásolásával(shallow copy, ez a default) az egyik tömb destruktora felszabadítja mindkét tömböt. <a href="https://en.wikipedia.org/wiki/Object_copying">https://en.wikipedia.org/wiki/Object_copying</a></p>
<p><em><strong>FONTOS!</strong></em> Néhány olvasó esetleg ismerheti a <code>memcpy</code> függvényt. C++ objektumokat <code>memcpy</code>-vel(és <code>std::memcpy</code>-vel) másolni óriási hiba, mivel ilyenkor nem hívódnak meg az objektumok másoló konstruktorai!</p>
<pre><code class="language-cpp">template &lt;typename T&gt;
class DinTomb{
    T* tomb; //pointer a dinamikus tömbre
    std::size_t meret; //a dinamikus tömb mérete

public:
    /**
     * @brief Default konstruktor, mindent 0-ra inicializál
     */
    DinTomb() : tomb(nullptr), meret(0) {}

    /**
     * @brief Másoló konstruktor
     * @param other a másik tömb amit másolunk
     */
    DinTomb(const DinTomb&amp; other) : tomb(other.tomb != nullptr ? new T[other.meret] : nullptr), meret(other.meret) {
        //                                          ^ ha nullptr a másik tömb(vagy 0 a mérete), akkor nem foglalunk 0 méretű tömböt(nem is lehetne...)
        for(std::size_t i = 0; i &lt; other.meret; ++i){
            tomb[i] = other.tomb[i];
        }
    }

    ~DinTomb() {
        delete[] tomb; //destruktor felszabadítja a lefoglalt memóriát
    }
};
</code></pre>
<h2 id="class-vs-struct"><a class="header" href="#class-vs-struct">class vs struct</a></h2>
<p>A <code>struct</code> keyword C++ -ban gyakorlatilag egy alternatíva osztályok definiálására. A <code>class</code> -tól annyiban különbözik, hogy <code>private</code> helyett alapértelmezetten minden <code>public</code> benne(C kompatibilitás miatt). Az, hogy valaki <code>class</code>-t vagy <code>struct</code>-ot használ, preferencia.</p>
<h2 id="osztályok-tagfüggvényei-többmodulos-programokban"><a class="header" href="#osztályok-tagfüggvényei-többmodulos-programokban">Osztályok tagfüggvényei többmodulos programokban</a></h2>
<p>Ha egy osztálynak saját header és cpp file-t dezignálunk, akkor azt a következő szintaxissal tehetjük meg:</p>
<p><code>foo.hpp</code> (a .hpp kiterjesztés gyakori c++ header fileokhoz, de természetesen a .h ugyanígy gyakori)</p>
<pre><code class="language-cpp">class foo{
    int x;
    static int y;
    public:
    foo(int x);
    void set_x(int x);
    int get_x() const;

    static void something();


    template &lt;typename T&gt;
    void print_with_x(T thing) const {
        std::cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; thing;
    }
};
</code></pre>
<p><em><strong>FONTOS!</strong></em> A template definíciókat (explicit specializációkat kivéve) header fileokban kell megírni!</p>
<p>A .cpp fileban a <code>returntype classname::functionname(params...)</code> szintaktikát használjuk.<br>
Statikus tagváltozókat itt kell definiálni, itt a <code>type classname::variablename = somevalue;</code> szintaktikát használjuk. Osztálydefiníción kívül a <code>static</code> mást jelent, így kiírni nagy hiba.
<code>foo.cpp</code></p>
<pre><code class="language-cpp">
int foo::y = 1; //statikus tagváltozó definíciója

foo::foo(int x) : x(x) {} //konstruktor definíciója

void foo::set_x(int x){
    this-&gt;x = x;
}

int foo::get_x() const { //fontos! a const része a függvény fejécének(signature), itt is ki kell írni.
    return x;
}

void foo::something(){
    y*=2;
}
</code></pre>
<h4 id="stdinitializer_list"><a class="header" href="#stdinitializer_list"><em>std::initializer_list</em></a></h4>
<p><a href="https://en.cppreference.com/w/cpp/utility/initializer_list">https://en.cppreference.com/w/cpp/utility/initializer_list</a></p>
<p>Ha szeretnénk a tömbünknek egy egyszerű inicializálási módszert adni, akkor átvehetünk egy <code>std::initializer_list</code> típusú objektumot konstruktor paraméterként.</p>
<p>Az <code>std::initializer_list</code> egy read-only "view", azaz módosítani nem tudjuk, viszont másolni tudunk belőle. Nincs sem <code>at()</code> tagfüggvénye, sem indexelő operátora, csak range-for ciklussal tudunk végigiterálni rajta.</p>
<pre><code class="language-cpp">template &lt;typename T&gt;
class DinTomb{
    T* tomb; //pointer a dinamikus tömbre
    std::size_t meret; //a dinamikus tömb mérete

public:
    /**
     * @brief Default konstruktor, mindent 0-ra inicializál
     */
    DinTomb() : tomb(nullptr), meret(0) {}

    /**
     * @brief initializer list konstruktor
     * @param init
     */
    DinTomb(std::initializer_list&lt;T&gt; init) : tomb(new T[init.size()]), meret(init.size()) {
        std::size_t i = 0;
        for(const T&amp; elem : init) {
            tomb[i] = elem;
            ++i;
        }
    }
};

int main(){
    DinTomb&lt;int&gt; tomb = {1, 2, 3, 4};
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="operator-overloading"><a class="header" href="#operator-overloading">Operator overloading</a></h1>
<h2 id="mik-az-operátorok-valójában"><a class="header" href="#mik-az-operátorok-valójában">Mik az operátorok valójában?</a></h2>
<p>Az operátorok valójában csak speciális függvények. Ez azt jelenti, hogy ugyanúgy bánhatunk velük, habár van némi megkötés, azonban legtöbbször ezek nem fognak az utunkban állni.</p>
<h2 id="operátorok-és-osztályok"><a class="header" href="#operátorok-és-osztályok">Operátorok és osztályok</a></h2>
<p>Ha egy operátor az adott osztály típust veszi át baloldali paraméterként, akkor az operátort az osztályon belül tagfüggvényként kezelhetjük. Ekkor valójában egy paramétert adunk neki, ami a jobb oldali operandus. A bal oldali operandusa implicit a <code>this</code> pointer lesz.</p>
<p>Szeretnénk, hogy a tömbünkhöz a += operátorral is lehessen új elemet hozzáadni. Ehhez túl kell töltenünk += operátort.
A += operátorra "függvényként" az <code>operator+=</code> kifejezéssel hivatkozhatunk.</p>
<p>Nézzünk egy példát:</p>
<pre><code class="language-cpp">class DinTomb{
    /* 
        ...
    */

    void operator+=(const T&amp; elem){
        push_back(elem); //delegáljuk a beillesztést a push_back függvénynek, nem duplikálunk kódot.
    }
};

int main(){
    DinTomb tomb;
    tomb += 5.2; // értelmezzük: tomb.operator+=(5.2) -&gt; operator+=(&amp;tomb, 5.2)

    return 0;
}
</code></pre>
<h2 id="friend"><a class="header" href="#friend">Friend</a></h2>
<p>Most szeretnénk, ha a tömbünket ki is lehetne írni. Viszont ezzel van egy kis gond. Azt, hogy hova írjuk ki a tömböt(stdout, file, stb.) balértékként veszi át az <code>operator&lt;&lt;</code> (stream insertion operator), ezért ezt az osztályon kívük kell túltölteni.
A <code>friend</code> kulcsszó használatával az osztályon belül deklaráljuk a függvényt, ezzel "megengedjuk" neki, hogy a privát tagokat is lássa. Eztunán az osztályon kívül definiáljuk.</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

class DinTomb{
    /* 
        ...
    */

    template&lt;typename K&gt;
    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const DinTomb&lt;K&gt;&amp; dtomb);
};

template&lt;typename K&gt;
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const DinTomb&lt;K&gt;&amp; dtomb){
    for(std::size_t i = 0; i &lt; dtomb.meret; ++i){
        out &lt;&lt; dtomb.tomb[i] &lt;&lt; ' ';
    }

    return out;
}

int main(){
    DinTomb tomb;
    tomb += 5.2; // értelmezzük: tomb.operator+=(5.2) -&gt; operator+=(&amp;tomb, 5.2)
    tomb += 2.3;
    tomb.push_back(8.7);

    std::cout &lt;&lt; tomb; //értsd: operator&lt;&lt;(std::cout, tomb);
    return 0;
}
</code></pre>
<p>Ha az <code>operator&lt;&lt;</code>-t streamre való kiírásra használjuk, akkor mindig <code>std::ostream&amp;</code> -et ad vissza és vesz át bal operandusként, valamint visszaadja a bal operandusát, így láncolhatóvá teszi az operátort. (<code>std::cout &lt;&lt; a &lt;&lt; b &lt;&lt; c;</code>)</p>
<p>Természetesen ezt a példát <code>friend</code> nélkül is meg lehet oldani, azonban ez nem mindig van így.</p>
<h2 id="copy-assignmentértékadó-operátor"><a class="header" href="#copy-assignmentértékadó-operátor">Copy assignment(értékadó operátor)</a></h2>
<p>Vannak olyan esetek, amikor már egy kész objektumnak akarunk új értéket adni.
Pl.</p>
<pre><code class="language-cpp">tomb&lt;int&gt; tomb1;
tomb1.push_back(5);

tomb&lt;int&gt; tomb2;
tomb2.push_back(1);

tomb1 = tomb2;
</code></pre>
<p>Ilyen esetekben egy értékadó operátor(copy assignment operator) hívásról beszélünk.</p>
<p>A másoló konstruktor testvére a copy assignment(értékadó) operator. A copy constructorhoz hasonlóan <code>const T&amp;</code> -ként veszi át a másolandó objektumot és a default is generálódik belőle.
Fontos, hogy a copy assignment operátor nem új objektumot hoz létre így az előzőleg használt erőforrásokat fel kell szabadítani.</p>
<pre><code class="language-cpp">template &lt;typename T&gt;
class DinTomb{
    T* tomb;
    std::size_t meret;

public:
    /**
     * @brief Default konstruktor, mindent 0-ra inicializál
     */
    DinTomb() : tomb(nullptr), meret(0) {}


    /**
     * @brief Másoló konstruktor
     * @param other a másik tömb amit másolunk
     */
    DinTomb(const DinTomb&amp; other) : tomb(other.tomb != nullptr ? new T[other.meret] : nullptr), meret(other.meret) {
        //                                          ^ ha nullptr a másik tömb(vagy 0 a mérete), akkor nem foglalunk 0 méretű tömböt(nem is lehetne...)
        for(std::size_t i = 0; i &lt; other.meret; ++i){
            tomb[i] = other.tomb[i];
        }
    }

    /**
     * @brief Értékadó operátor
     * @param other a másik tömb amit másolunk
     * @return referencia a tömbre aminek értéket adtunk
     */
    DinTomb&amp; operator=(const DinTomb&amp; other){
        if(this == &amp;other) { //ha önmagát kapja paraméterül akkor nincs semmi teendő, ne vágjuk magunk alatt a fát
            return *this; // *this -&gt; this pointer, *this referencia(az objektumra amin a hívás történt)
        }
        delete[] tomb;
        tomb = new T[other.meret];
        meret = other.meret;
        for(std::size_t i = 0; i &lt; other.meret; ++i) {
            tomb[i] = other.tomb[i];
        }
        return *this;
    }

    ~DinTomb() {
        delete[] tomb;
    }

    std::size_t size() const;

    void push_back(const T&amp; elem);

    T&amp; at(std::size_t idx);

    T&amp; at(std::size_t idx) const;
};

int main(){

}
</code></pre>
<h2 id="rule-of-03"><a class="header" href="#rule-of-03">Rule of 0/3</a></h2>
<p><a href="https://en.cppreference.com/w/cpp/language/rule_of_three">https://en.cppreference.com/w/cpp/language/rule_of_three</a></p>
<p>Rule of 3: Ha egy osztálynak szüksége van nem compiler-default destruktorra, másoló konstruktorra vagy copy assignment operátorra akkor majdnem biztosan szüksége van mindháromra.</p>
<p><strong><em>advanced</em></strong><br>
Rule of 0: Azok az osztályok, amelyeknek nem compiler-default destructora, copy constructora, copy assignment operátora van, azok valamilyen explicit erőforrás-birtoklást valósítanak meg. (<a href="https://en.cppreference.com/w/cpp/language/rule_of_three">https://en.cppreference.com/w/cpp/language/rule_of_three</a>). Ettől eltérő osztályoknak ne legyen nem compiler-default destruktora, copy constructora vagy copy assignment operátora.</p>
<h2 id="néhány-kötöttség"><a class="header" href="#néhány-kötöttség">Néhány kötöttség</a></h2>
<p>Operátor túltöltéssel nem változtatható meg:</p>
<ul>
<li>precedencia</li>
<li>asszocivitás</li>
</ul>
<p>Ezen felül egyes operátoroknak csak kötött számú paramétere lehet.<br>
A logikai(<code>||</code> és <code>&amp;&amp;</code>) operátorok túltöltése esetén azok elvesztik a short-circuit tulajdonságukat.</p>
<h2 id="Összehasonlító-operátorok"><a class="header" href="#Összehasonlító-operátorok">Összehasonlító operátorok</a></h2>
<p>Természetesen mindenféle más operátorokat, pl összehasonlító, ennek negáltja, nagyobb, kisebb, stb. is overloadolhatunk.</p>
<p>Pl. a tömbjeink összehasonlítása:</p>
<pre><code class="language-cpp">template &lt;typename T&gt;
class DinTomb{
    T* tomb; //pointer a dinamikus tömbre
    std::size_t meret; //a dinamikus tömb mérete

public:
    //...

    bool operator==(const DinTomb&amp; other) {
        if(meret != other.meret) {
            return false;
        }

        for(std::size_t i = 0; i &lt; meret; ++i) {
            if(tomb[i] != other.tomb[i]) {
                return false;
            }
        }

        return true;
    }

    bool operator !=(const DinTomb&amp; other) {
        return !(*this == other);
    }
};

</code></pre>
<p>Pl. indexelő operátor:</p>
<pre><code class="language-cpp">template &lt;typename T&gt;
class DinTomb{
    T* tomb; //pointer a dinamikus tömbre
    std::size_t meret; //a dinamikus tömb mérete

public:
    //...

    T&amp; at(std::size_t idx);

    const T&amp; at(std::size_t idx);

    T&amp; operator[](std::size_t idx){
        return at(idx); //delegáljuk a feladatot a már implementált at() tagfüggvénynek
    }

    const T&amp; operator[](std::size_t idx) const{
        return at(idx);
    }
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="objektumorientált-idióma"><a class="header" href="#objektumorientált-idióma">Objektumorientált idióma</a></h1>
<p>Senkit sem szeretnék a sablonszöveggel untatni, ha szép és kerek leírást keresünk arra itt a <a href="https://en.wikipedia.org/wiki/Object-oriented_programming">wikipédia</a>.</p>
<h4 id="a-lényeg"><a class="header" href="#a-lényeg">A lényeg</a></h4>
<p>Az objektumorientált programozás alapja, hogy minden <em>dolog</em> ami a programunkban létezik egy objektum.</p>
<p><em>Encapsulation</em> (Egységbe zárás)<br>
Az objektumok valamilyen blueprintek(C++ban classok) példányai. Az osztályok valamilyen állapotot és az azokon elvégezhető műveleteket írják le(tagváltozó ~ állapot, tagfüggvény ~ művelet).</p>
<p><em>Inheritance</em> (öröklődés)<br>
Van olyan eset, amikor egy adott dolog egyben egy másik dolog, csak kicsit kiegészítve, megváltoztatva. Pl. a Hallgató egy egyetemi polgár, viszont képes vizsgát felvenni és van kreditindexe.
Ekkor az egyetemi polgár a <em>"base class"</em> a hallgató pedig a "<em>subclass</em>" nevet kapja.</p>
<p><em>Polymorphism</em><br>
Kéz a kézben jár a leszármaztatással. A fő lényege, hogy egy base class -ra mutató dolog kaphat subclass objektumot, és ezen a mutatón keresztül való viselkedés a subclass viselkedését mutatja.</p>
<p><em>Abstraction</em><br>
A legtöbb esetben nem érdekel minket, hogy egy adott függvény vagy típus pontosan hogy működik, csak az, hogy mit csinál. Pl. az <code>std::string</code> <code>push_back()</code> tagfüggvénye beilleszt egy karaktert a sztring végére, de az hogy ezt hogy tesz az az átlag programozó számára(a típus felhasználója) nem érdekes.
Ezt az elvet a jegyzet is alkalmazni fogja, nem lesznek definiálva tagfüggvények, ha azok implementációja jelentéktelen.</p>
<h2 id="inheritance"><a class="header" href="#inheritance">Inheritance</a></h2>
<p>A leszármazás szintaktikája viszonylag egyszerű:</p>
<pre><code class="language-cpp">class polgar{
public:
    std::string name;
    std::string neptun;
    std::string get_decorated_name() const {
        return name + std::string(" ") + neptun;
    }
};

class hallgato : public polgar {
public:
    double calculate_kreditindex();
    std::vector&lt;Targy&gt; targyak;
};
</code></pre>
<p>Egy adott leszármazott példány memóriaképét ekkor valahogy így kell elképzelni:<br>
<img src="image-2.png" alt="&quot;&quot;" /></p>
<p>Egyszerre több osztályból is le lehet származni, valamint leszármazottból is lehet tovább származtatni:</p>
<pre><code class="language-cpp">class A {};
class B {};
class C : public A, public B {}

class D : public A {};
class E : public D {};
</code></pre>
<h2 id="polimorfizmus"><a class="header" href="#polimorfizmus">Polimorfizmus</a></h2>
<p>Ha <code>hallgato</code> a <code>polgar</code> leszármazottja, akkor <code>polgar</code> -ra mutató pointerek már képesek <code>hallgato</code> -ra mutatni, valamit <code>polgar</code> referencia tud <code>hallgato</code> objektumot alias-olni.
<em><strong>FONTOS!</strong></em> Az inverz nem igaz.</p>
<pre><code class="language-cpp">hallgato* h = new polgar;
</code></pre>
<p>hiszen itt a <code>h</code> egy olyan objektumra mutat amiben nincs meg a teljes <code>hallgato</code> rész.</p>
<p><em><strong>FONTOS!</strong></em>
<code>polgar</code> típusú változóban <code>hallgato</code> objektumot tárolni és fordítva hiba! <code>polgar</code> típusú változóba <code>halgato</code> típusú objektumot rakva az objektum <code>hallgató</code> része levágódik és csak a <code>polgar</code> része marad meg. Ezt <em>object slicing</em>-nak hívjuk.</p>
<h2 id="protected-tagok"><a class="header" href="#protected-tagok">Protected tagok</a></h2>
<p>A <code>private</code> tagok nem láthatók a leszármazottakból sem. A <code>protected</code> tagok a leszármazottból látszanak, az osztályon kívülről viszont nem.</p>
<h2 id="inheritance-access-specifiers"><a class="header" href="#inheritance-access-specifiers">Inheritance access specifiers</a></h2>
<p>Mint ahogyan tagokból, leszármazásból is létezik publikus, protected és private.</p>
<pre><code class="language-cpp">class Base {};
class A : public Base {};
class B : protected Base {};
class C : private Base {};
</code></pre>
<p>Ezt a következőképp kell érteni:</p>
<p><strong>public</strong>: a subclass és a külső kód is tud a leszármazásról, a leszármazotton keresztül a subclass és a külső kód is eléri a base class <code>public</code> tagjait, a <code>private</code> és <code>protected</code> tagokat viszont nem
<strong>protected</strong>: csak a subclass tud a leszármazásról, a leszármazotton keresztül csak a subclass éri el a base class <code>public</code> tagjait, a külső kód viszont egyáltalán nem éri el a base class tagjait
<strong>private</strong>: a subclass sem tud a leszármazásról, a leszármazotton keresztül nem érhetőek el a base class tagjai.</p>
<p>A <code>struct</code>-al definiált osztályoknál a leszármazásnál is <code>public</code> a default, míg a <code>class</code>-al definiáltaknál <code>private</code>.</p>
<p>Gyakori kérdés: hogyan alakul a publikus, protected és privát tagok láthatósága publikus, protected és privát öröklés esetén?
<em>... megoldását az olvasóra bízom</em></p>
<h2 id="virtuális-tagfüggvények"><a class="header" href="#virtuális-tagfüggvények">Virtuális tagfüggvények</a></h2>
<p>Tegyük fel, hogy a hallgatók dekorált nevéhez hozzá szeretnénk adni, hogy "hallgató". Ehhez valahogyan "felül kell írnunk" a base class <code>get_decorated_name</code> függvényét. Azokat a függvényeket amelyeket felül lehet írni virtuális tagfüggvényeknek hívunk és a <code>virtual</code> keyworddel jelezzük őket.
A base class-ra mutató pointeren keresztül tárolt subbclassnak a saját tagfüggvény verziója hívódik majd.</p>
<p>Az <code>ovverride</code> keyword opcionálisan a felülíró függvény fejléce után kerül, hasznos kiírni.</p>
<p><a href="https://godbolt.org/z/j7a3jW9fP">https://godbolt.org/z/j7a3jW9fP</a></p>
<pre><code class="language-cpp">#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

struct Targy {};

class polgar{
public:
    std::string name;
    std::string neptun;
    virtual std::string get_decorated_name() const {
        return name + std::string(" ") + neptun;
    }
};

class hallgato : public polgar {
public:
    double calculate_kreditindex();
    std::vector&lt;Targy&gt; targyak;

    virtual std::string get_decorated_name() const override {
        return std::string("hallgato ") + name + std::string(" ") + neptun;
    }
};

int main(){
    polgar* p = new hallgato;
    p-&gt;name = "Gipsz Jakab";
    p-&gt;neptun = "ABC123";
    std::string name = p-&gt;get_decorated_name(); //hallgato tagfüggvényét hívja
    std::cout &lt;&lt; name; //hallgato Gipsz Jakab ABC123
}
</code></pre>
<h3 id="vtable"><a class="header" href="#vtable">Vtable</a></h3>
<p>A virtuális függvényhívások egy speciális, vtable -nek nevezett adatstruktúrán keresztül történik. Amikor virtuális függvényt adunk egy osztályhoz, akkor az osztály kap egy rejtett tömböt, amely függvénypointereket("függvényeket") tárol. Ez a tömb tárolja az adott osztály implementációját a virtuális függvényekre.</p>
<p><em>Miért szükséges ez?</em><br>
Mivel base class pointer mutathat subclass objektumra, így fordításidőben nem tudhatjuk, hogy melyik függvényt kell hívni, ezért futásidőben ezt a tömböt használjuk, hogy a helyes függvényt hívjuk.</p>
<p><em>Mekkora overheaddel jár ez?</em><br>
A válasz: depends. Gyakorlatilag semekkorával, persze ez sok tényezőtől függ. Gyenge hardveren(pl. mikrokontrollerek) problémát jelenthet, azonban egy asztali számítógépen valószínűleg nem ez lesz a szűk keresztmetszet.</p>
<h3 id="pure-virtual-function-absztrakt-osztályok"><a class="header" href="#pure-virtual-function-absztrakt-osztályok">Pure virtual function, absztrakt osztályok</a></h3>
<p>Néha szeretnénk azt, hogy a base class ne legyen valóban példányosítható, hanem valamilyen függvényét implementálja minden subclass. Az ilyen függvényeket pure virtual functionnak, az osztály t pedig absztrakt osztálynak nevezzük. Pure virtual function-t az <code>=0</code> postfix-el deklarálhatunk.</p>
<pre><code class="language-cpp">struct base {
    virtual void foo() = 0;
};

struct derived : base {
    virtual void foo() override {
        std::cout &lt;&lt; "pog\n";
    }
}

int main(){
    base b; //error, cannot instantiate abstract class
    derived d; //ok
    base* p = new derived; //ok, base* mutat derived objektumra
    base* p2 = new base; //error, cannot instantiate abstract class

}
</code></pre>
<p><em>Vegyük észre</em>: az <code>=0</code> szintaxis onnan jön, hogy a vtable-ben a függvény helyén egy 0 érték, "null pointer" lesz.</p>
<h2 id="base-class-konstruktor-és-virtuális-destruktor"><a class="header" href="#base-class-konstruktor-és-virtuális-destruktor">Base class konstruktor és virtuális destruktor</a></h2>
<p>Amikor egy leszármazott objektumot készítünk, akkor inicializálni kell annak base class "részét" is. Ehhez meg kell hívni a base class destruktorát(ha nincs neki default konstruktora).
Ezt a már jól ismert member initializer list-ről tehetjük meg.</p>
<p><a href="https://godbolt.org/z/cndqTPEMj">https://godbolt.org/z/cndqTPEMj</a></p>
<pre><code class="language-cpp">#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

struct Targy {};

class polgar{
protected:
    std::string name;
    std::string neptun;

public:
    virtual std::string get_decorated_name() const {
        return name + std::string(" ") + neptun;
    }
    polgar(const std::string&amp; name, const std::string&amp; neptun) : name(name), neptun(neptun) {}
};

class hallgato : public polgar {
    std::vector&lt;Targy&gt; targyak;
public:
    hallgato(const std::string&amp; name, const std::string&amp; neptun) : polgar(name, neptun) //a polgar konstruktorát hívjuk a name és neptun paraméterekkel
    {}

    double calculate_kreditindex();

    virtual std::string get_decorated_name() const override {
        return std::string("hallgato ") + name + std::string(" ") + neptun;
    }
};

int main(){
    polgar* p = new hallgato("Gipsz Jakab", "ABC123");

    std::string name = p-&gt;get_decorated_name(); //hallgato tagfüggvényét hívja
    std::cout &lt;&lt; name; //hallgato Gipsz Jakab ABC123
}
</code></pre>
<pre><code class="language-cpp">polgar* p = new hallgato("Gipsz Jakab", "ABC123");
</code></pre>
<p>Azonban van egy kis baj...</p>
<p>A probléma a destruktor kérdése. Ha a base classra mutató pointerre hívunk <code>delete</code> -t, akkor az a base class destruktorát fogja meghívni. Ez probléma, ha a subclass destruktora valamilyen erőforrást szabadít fel, viszont nem hívódik meg.</p>
<p>Erre a problémára nyújtanak megoldást a virtuális destruktorok. Amikor egy base-re mutató pointerre <code>delete</code>-t hívunk, akkor a láncon felfelé(legalsó leszármazott-&gt;legfelső leszármazott) meghívódik az összes destruktor.</p>
<p><a href="https://godbolt.org/z/GfT89Edne">https://godbolt.org/z/GfT89Edne</a></p>
<pre><code class="language-cpp">struct base {
    base() = default; //explicit default: "im okay with what the compiler gives me" (C++11 -től)
    virtual ~base() {
        std::cout &lt;&lt; "base dtor\n";
    }
};

struct derived : base {
    derived() = default;
    virtual ~derived() {
        std::cout &lt;&lt; "derived dtor\n";
    }
};

int main(){
    base* p = new derived;
    delete p;
}
</code></pre>
<p>Output:</p>
<pre><code>derived dtor
base dtor
</code></pre>
<h2 id="final-keyword"><a class="header" href="#final-keyword">'final' keyword</a></h2>
<p>A <code>final</code> keyword azt jelzi, hogy egy osztályból már nem lehet leszármazni.</p>
<pre><code class="language-cpp">struct something final {};

struct something_else : something {}; //error, 'something' is final
</code></pre>
<h2 id="virtual-inheritance"><a class="header" href="#virtual-inheritance">Virtual inheritance</a></h2>
<p>A gyémánt probléma az OOP egyik legnagyobb kérdése.</p>
<pre><code class="language-cpp">struct A {
    int x;
};
struct B : A {};
struct C : A {};
struct D : B, C {};
</code></pre>
<p>Ekkor a leszármazási gráf egy "gyémánt" alakot alkot, amely a következő problémát veti fel: <br>
Amikor a <code>D</code> -n keresztül <code>A</code> beli tagokat érünk el, akkor azt a <code>D</code> osztály <code>B</code> vagy <code>C</code> részén tesszük -e meg?<br>
Ez akkora dilemma, hogy sok nyelv (pl. Java) szimplán nem enged egyszerre több osztályból való származást.</p>
<p>C++ -ban ezt a problémát a virtuális leszármazással oldották meg.</p>
<p>Minden virtuálisan örökölt osztályból garantáltan csak egyet tartalmaz majd minden leszármazott, akkor is, ha az osztály többször is szerepel a hierarchiában. <br>
A virtuális ősosztályok minden nem-virtuális ősosztály előtt jönnek létre és a virtuális base classok konstruktorát csak a hierarchiában legalsó osztály konstruktora fogja meghívni.</p>
<p>B konstruktora hívódik meg először, mivel virtual base class. Ez az <code>AA</code> initializer listjének sorrendjétől független, sőt, warningot is kapunk, ha B nem legelől van.<br>
Ezután következik <code>X</code> és <code>Y</code> konstruktora, hiszen az <code>A</code> konstruktor törzse csak az initializer list után, az objektum inicializálása után fog lefutni.</p>
<p>A destruktor hívások a konstruktor hívásokkal ellentétes sorrendben történnek.</p>
<p><a href="https://godbolt.org/z/s6PqqjP1a">https://godbolt.org/z/s6PqqjP1a</a></p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

struct B
{
    int n;
 
    B(int x) : n(x) {
        std::cout &lt;&lt; "b ctor\n";
    }
};
 
struct X : virtual B { 
    X() : B(1) {
        std::cout &lt;&lt; "x ctor\n";
    } 
};
struct Y : virtual B {
    Y() : B(2) {
        std::cout &lt;&lt; "y ctor\n";
    }  
};
struct AA : X, Y     {
    AA() : B(3), X(), Y() {
        std::cout &lt;&lt; "a ctor\n";
    } 
};

int main(){
    AA x;
}
</code></pre>
<p>A kódrészletben a konstruktor hívások sorrendje:</p>
<ul>
<li>B konstruktor</li>
<li>X konstruktor</li>
<li>Y konstruktor</li>
<li>A konstruktor</li>
</ul>
<h2 id="saját-exception"><a class="header" href="#saját-exception">Saját exception</a></h2>
<p>Korábban már szerepelt, hogy lehetséges saját kivételeket létrehozni. Ehhez semmi mást nem kell csinálni, mint az <code>std::exception</code>, vagy legtöbb esetben inkább az <code>std::runtime_error</code> osztályból leszármazni. A kivételeknek van egy konstruktora amely egy hibaüzenetet vesz át, ezért ezt implementáljuk.</p>
<p><a href="https://godbolt.org/z/a6rTb3cnG">https://godbolt.org/z/a6rTb3cnG</a></p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;stdexcept&gt;

struct image_load_error : std::runtime_error {
    image_load_error(const std::string&amp; what) : std::runtime_error(what) {}
};

struct image{
    image(const std::string&amp; path){
        if(path.empty()){
            throw image_load_error("Image Load Error: image cannot have empty path!");
        }
    }
};

int main(){
    try{
        image img("");
    }catch(const image_load_error&amp; img_error){
        std::cout &lt;&lt; img_error.what();
    }catch(std::exception&amp; e){
        std::cout &lt;&lt; e.what();
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="heterogén-tárolók"><a class="header" href="#heterogén-tárolók">Heterogén tárolók</a></h1>
<h2 id="polimorphism-by-inheritance"><a class="header" href="#polimorphism-by-inheritance">Polimorphism by inheritance</a></h2>
<p>Az öröklés alapú polimorfizmus alapja az előző fejezetben is említett örökléses memóriakép:
<img src="image-2.png" alt="" /></p>
<p>Ezen láthatjuk, hogy egy <code>struct B : A</code> osztály egy példánya egyben egy <code>A</code> osztály példánya is, ezért <code>A</code> típusra mutató pointer/referencia mutathat <code>B</code> példányra is.</p>
<p>Ezek alapján készíthetünk egy olyan tárolót, amely egy adott típusból leszármazó objektumokra mutató pointereket tárol. Az ilyen tárolókat hívjuk heterogén kollekciónak.</p>
<p><strong>Ownership kérdés</strong>: Egy heterogén kollekció esetén két opciónk van:</p>
<ul>
<li>A kollekció birtokolja a tárolt objektumokat. Ez azt jelenti, hogy a kollekció élettartama végén fel kell szabadítania a tárolt elemeket.</li>
<li>A kollekció nem birtokolja az elemeket, ekkor a felhasználó feladata az elemek felszabadítása.</li>
</ul>
<p>Heterogén kollekciók esetén általában az első opciót választjuk.</p>
<h2 id="heterogén-kollekció-konstrukciója"><a class="header" href="#heterogén-kollekció-konstrukciója">Heterogén kollekció konstrukciója</a></h2>
<p>Tároljunk "komponens"eket, amelyeknek van egy virtuális <code>use()</code> tagfüggvénye.
Szükségünk lesz:</p>
<ul>
<li>Valamilyen <code>Component*</code> tömbre</li>
<li>Méretet tároló egészre</li>
<li>hozzáadó tagfüggvényre</li>
<li>indexelő operátorra</li>
<li>destruktorra</li>
<li>másoló konstruktorra és értékadó operátorra(vagy ha nem kell, akkor priváttá tesszük ezeket, C++11 -től <code> = delete;</code> is jó)</li>
</ul>
<p>Az első két pontot egyesíthetjük egy <code>std::vector&lt;Container*&gt;</code> használatával(C++ standard library dinamikus tömbje), vagy egy saját dinamikus tömb implementációval. (ld. előző fejezet)</p>
<p>A hozzáadó tagfüggvényünk egy <code>Container*</code>-ot vesz át, amit a hívó fél a <code>new</code> operátor visszatérési értékeként kapott. Ez a függvény "átveszi a birtokos szerepét"(<em>takes ownership</em>) a hívótól. Ezt érdemes kommentként jelezni.</p>
<p><a href="https://godbolt.org/z/hdvobeddz">https://godbolt.org/z/hdvobeddz</a></p>
<pre><code class="language-cpp">#include &lt;cstdint&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;

struct Component{
    virtual void use() = 0;
    virtual ~Component() = default;
};

struct SomeComponent : Component{
    SomeComponent(int gears) : gears(gears) {}
    int gears;
    virtual void use() override{
        fixSimpleMachine();
    }

    void fixSimpleMachine() {
        std::cout &lt;&lt; "fixed simple machine, gears: " &lt;&lt; gears &lt;&lt; '\n';
    }
    virtual ~SomeComponent() = default;
};

struct ComponentStore{
    ComponentStore() = default;

    std::size_t size() const { return components.size(); }

    void push_back(Component* component) {
        components.push_back(component);
    }

    Component* operator[](std::size_t idx){
        return components[idx];
    }

    ~ComponentStore(){
        for(Component* component : components){ //range based for ciklus, ld. iterátorok
            delete component;
        }
    }

    private:
        ComponentStore(const ComponentStore&amp;);
        ComponentStore&amp; operator=(const ComponentStore&amp;);
        std::vector&lt;Component*&gt; components;
};

int main(){
    ComponentStore components;
    components.push_back(new SomeComponent(5));
    components[0]-&gt;use(); 
}
</code></pre>
<h3 id="kitérő-stdunique_ptr-c11--től"><a class="header" href="#kitérő-stdunique_ptr-c11--től"><em>Kitérő: std::unique_ptr</em> (C++11 -től)</a></h3>
<p><em>Ez a fejezet túlmutat a tárgy anyagán. A <code>unqiue_ptr</code> használatához sokszor szükségesebb bonyolultabb koncepciók, amelyeket a jegyzet végén "kitérő" fejezetekben tárgyal.</em></p>
<p>Gyakran szeretnénk egy dinamikusan foglalt objektumot valamilyen másik objektum élettartamához kötni. Erre az esetre létezik egy pointert csomagoló <code>std::unique_ptr</code> osztály. Ugyanúgy működik, mint egy pointer, van <code>*</code> és <code>-&gt;</code> operátora, viszont a <code>unique_ptr</code> objektum élettartama végén felszabadítja a tárolt pointert. Nem másolható(hiszen "unique"), ezzel biztosítja, hogy egyszerre csak egy objektum birtokolja a memóriát, amire mutat. Referencia paraméterként természetesen átvehető, ez nem okoz másolást.</p>
<p>A <code>unqiue_ptr</code>-hez az <code>std::make_unique</code> függvénnyel tudunk objektumot foglalni. Amit paraméterként adunk neki, azt továbbadja az objektum konstruktorának.
Emellett a <code>uniqure_ptr</code> konstruktora kaphat már lefoglalt objektumra mutó pointert is.</p>
<pre><code class="language-cpp">std::unique_ptr&lt;Foo&gt; p = std::make_unique&lt;Foo&gt;(3, "bar"); //Foo* p = new Foo(3, "bar")
Foo* f = new Foo(2, "asd");
std::unqiue_ptr&lt;Foo&gt; p2(f); //p2 takes ownership of f, so delete f; is not necessary
</code></pre>
<p><code>unique_ptr</code> -el átírva a heterogén kollekciónkat:</p>
<pre><code class="language-cpp">struct ComponentStore{
    ComponentStore() = default;

    std::size_t size() const { return components.size(); }

    void push_back(Component* component) {
        components.push_back(std::unique_ptr&lt;Component&gt;(component));
    }

    std::unique_ptr&lt;Component&gt;&amp; operator[](std::size_t idx){
        return components[idx];
    }

    ~ComponentStore() = default; 

    private:
        ComponentStore(const ComponentStore&amp;);
        ComponentStore&amp; operator=(const ComponentStore&amp;);
        std::vector&lt;std::unique_ptr&lt;Component&gt;&gt; components;
};
</code></pre>
<p>Így már nem kell explicit dtor, az std::vector dtora meghívja az elemeinek dtorát. A <code>unqiue_ptr</code> destruktora pedig felszabadítja a memóriát.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iterátorok"><a class="header" href="#iterátorok">Iterátorok</a></h1>
<p>Most elengedjük egy kicsit a tömböket, és megnézünk egy láncolt lisát.</p>
<pre><code class="language-cpp">template &lt;typename T&gt;
class List{
    struct node{ //belső osztály, List&lt;T&gt;::node
        T data;
        node* next;
    };

    node* m_head;
    node* m_back;
    std::size_t m_size;

public:
    List() : m_head{nullptr}, m_back(nullptr), m_size(0) {}

    List(const List&amp; other) : m_head(nullptr), m_back(nullptr), m_size(0) {
        for(const auto&amp; elem : other) {
            push_back(elem);
        }
    }

    ~List() {
        node* iter = m_head;
        while (iter != nullptr) {
            node* tmp = iter;
            iter = iter-&gt;next;
            delete tmp;
        }
    }

    void push_front(T data) {
        node* uj = new node;
        uj-&gt;data = data;
        uj-&gt;next = m_head;
        if(m_size == 0) {
            m_back = uj;
            m_head = uj;
        }else {
            m_head = uj;
        }
        ++m_size;
    }

    void push_back(const T&amp; data) {
        if(m_size == 0) {
            push_front(data);
            return;
        }else {
            node* uj = new node;
            uj-&gt;data = data;
            uj-&gt;next = nullptr;
            m_back-&gt;next = uj;
            m_back = m_back -&gt; next;
        }
        ++m_size;
    }

    std::size_t size() const {
        return m_size;
    }
};
</code></pre>
<p>Ha ezen a listán végig szeretnénk iterálni, akkor az valamilyen ronda <code>-&gt;next</code> és <code>==nullptr</code> -el teli kódot eredményezne.</p>
<p>Ehelyett készíthetünk egy segédosztályt, amely az iterálás lépéseit absztraktálja el. Az ilyen osztályokat nevezzük iterátornak.
Ahhoz, hogy egy iterátor használható legyen legalább szükség van valamilyen léptető operátorra, dereferencia operátorokra, valamint összehasonlító(== != stb.) operátorokra is.</p>
<p>Pl.:</p>
<p><a href="https://godbolt.org/z/qchjxE9en">https://godbolt.org/z/qchjxE9en</a></p>
<pre><code class="language-cpp">template &lt;typename T&gt;
class List{
    struct node{
        T data;
        node* next;
    };

public:
    struct iterator{
        friend class List; 
    private:
        node* it; //az iterátor egy pointer absztrakció, azt tárolja hogy éppen melyik node-ra mutat
        explicit iterator(node* it) : it(it) {} //privát konstruktor, nem kell hogy a hívó fél manuálisan csináljon iterátorokat
    public:
        iterator(const iterator&amp; other) : it(other.it) {}
        
        iterator&amp; operator= (const iterator&amp; other) {
            it = other.it;
            return *this;
        }

        /**
         * @brief léptető preincrement operátor, a current = current-&gt;next műveletet absztraktálja
         * @return
         */
        iterator&amp; operator++() {
            it = it-&gt;next;
            return *this;
        }

        /**
         * @brief összehasonlító operátor FONTOS!
         * @param other
         * @return
         */
        bool operator==(const iterator&amp; other) const {
            return it == other.it;
        }

        /**
         * @brief összehasonlító operátor FONTOS(talán a legfontosabb)
         * @param other
         * @return
         */
        bool operator!=(const iterator&amp; other) const {
            return  !(it == other.it);
        }

        /**
         * @brief dereferencia operátor
         * @return
         */
        T&amp; operator*() {
            return it-&gt;data;
        }

        /**
         * @brief konstans dereferencia operátor
         * @return
         */
        const T&amp; operator*() const {
            return it-&gt;data;
        }

        /**
         * @brief nyíl operátor ha az iterátoron keresztül közvetlen egy osztály tagjait akarjuk elérni
         * @return
         */
        T* operator-&gt;() {
            return &amp;(it-&gt;data);
        }

        //ugyanaz mint a másik, csak konstans
        T* operator-&gt;() const {
            return &amp;(it-&gt;data);
        }
    };

private:
    node* m_head; //lista első eleme
    node* m_back; //lista utolsó, még érvényes eleme
    std::size_t m_size; //lista mérete

public:
    List() : m_head{nullptr}, m_back(nullptr), m_size(0) {}

    List(const List&amp; other) : m_head(nullptr), m_back(nullptr), m_size(0) {
        for(const auto&amp; elem : other) {
            push_back(elem);
        }
    }

    ~List();

    void push_front(T data);

    void push_back(const T&amp; data);

    std::size_t size() const;

    /**
     * @brief begin tagfüggvény az iteráláshoz
     * @return az első elemre mutató iterátor
     */
    iterator begin() {
        return iterator(m_head);
    }

    // Minden iterátort visszaadó tagfüggvényből készül konstans verzió is ami konstans iterátort ad vissza.
    const iterator begin() const {
        return iterator(m_head);
    }

    /**
     * @brief end tagfüggvény az iteráláshoz
     * @return az utolsó érvényes elem "után" mutató iterátor, "sentinel" iterátor
     */
    iterator end() {
        return m_back == nullptr ? iterator(m_back) : iterator(m_back-&gt;next);
    }
    
    const iterator end() const {
        return m_back == nullptr ? iterator(m_back) : iterator(m_back-&gt;next);
    }
};

int main(){
    List&lt;int&gt; list;

    for(int i = -3; i &lt; 5; ++i){
        list.push_back(i);
    }

    for(List&lt;int&gt;::iterator it = list.begin(); it != list.end(); ++it) {
        std::cout &lt;&lt; *it &lt;&lt; ' ';
    }

    std::cout &lt;&lt; '\n';
    *list.begin() = 5;

    for(int elem : list) { //minden elemet lemásolunk egyesével
        std::cout &lt;&lt; elem &lt;&lt; ' ';
    }
}
</code></pre>
<p>A fent látott</p>
<pre><code class="language-cpp">for(List&lt;int&gt;::iterator it = list.begin(); it != list.end(); ++it) {
        std::cout &lt;&lt; *it &lt;&lt; ' ';
}
</code></pre>
<p>kódrészlet olyan gyakori, hogy külön szintaxis létezik rá:</p>
<pre><code class="language-cpp">for(int elem : list) { //minden elemet lemásolunk egyesével
        std::cout &lt;&lt; elem &lt;&lt; ' ';
}

for(int&amp; elem : list) { //minden elemre referenciával hivatkozunk
        std::cout &lt;&lt; elem &lt;&lt; ' ';
}

for(const int&amp; elem : list) { //ua. mint az előbb, csak konstans referenciával
        std::cout &lt;&lt; elem &lt;&lt; ' ';
}
</code></pre>
<p>Gondoljunk az iterátorokra úgy, mint a felturbózott pointerekre. Minden iterátor valamilyen tárolóhoz igazított, speciális mutató típus.</p>
<p>A következő fejezetben azt láthatjuk, hogy valójában a pointerek a tömb féle tárolók iterátorai.</p>
<h2 id="iterátorok-tömbök-és-pointerek"><a class="header" href="#iterátorok-tömbök-és-pointerek">Iterátorok, tömbök és pointerek</a></h2>
<p>A pointerek kielégítik az iterátorok legmélyebb követelményét, a <a href="https://en.cppreference.com/w/cpp/named_req/RandomAccessIterator"><em>LegacyRandomAccessIterator</em></a> követelményt.
Ez azt jelenti, hogy egy dinamikus tömbnél például nincs szükség külön iterátor osztályra, hiszen elég a pointereket léptetni és összehasonlítani.</p>
<p>Ez azt jelenti, hogy egy dinamikus tömböt elég ennyivel kiegészíteni:</p>
<pre><code class="language-cpp">    T* begin() {
        return tomb;
    }

    const T* begin() const {
        return tomb;
    }

    T* end() {
        return tomb + meret;
    }

    const T* end() const {
        return tomb + meret;
    }
</code></pre>
<h2 id="kiegészítés-iterátorok-besorolása"><a class="header" href="#kiegészítés-iterátorok-besorolása">Kiegészítés: Iterátorok besorolása</a></h2>
<p><img src="image-5.png" alt="alt text" /></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="predikátumok"><a class="header" href="#predikátumok">Predikátumok</a></h2>
<p>Van, hogy egy függvényt szeretnénk paraméterként átvenni.</p>
<p>Pl. írjunk függvényt, amely egy másik, predikátumfüggvény alapján megkeres egy elemet egy tömbben és visszaadja az indexét, vagy a tömb méretét(az első "invalid" elem indexét) ha nincs benne.</p>
<pre><code class="language-cpp">template&lt;typename T, std::size_t N, typename P&gt;
std::size_t find_elem(const std::array&lt;T, N&gt;&amp; a, P predicate){
    for(std::size_t i = 0; i &lt; a.size(); ++i){
        if(predicate&lt;T&gt;(a[i])){
            return i;
        }
    }
    return a.size()
}

//egy példa predikátumfüggvény:

template&lt;typename T&gt;
bool isDivisibleBy2(const T&amp; x){
    return x % 2 == 0;
}

int main(){
    std::array&lt;int, 4&gt; arr = {1, 3, 4, 5};
    std::cout &lt;&lt; find_elem(arr, isDivisbleBy2);
}
</code></pre>
<h2 id="nem-csak-függvények"><a class="header" href="#nem-csak-függvények">Nem csak függvények...</a></h2>
<p>A fenti példában a <code>P</code> típus helyére minden olyan típus beilleszthető, amely <code>bool</code> -t(vagy <code>bool</code>-ra implicit konvertálható típust) ad vissza és egy <code>const T&amp;</code> -et vesz át paraméterként. Az a kérdés, hogy csak függvények elégíthetik -e ki ezt a követelményt.</p>
<p>Nos a válasz erre az, hogy nem, ugyanis a függvényhívás operátor újratölthető. Azokat az osztályokat amelyeknek van függvényhívó operátora <em>funktor</em>nak nevezzük.</p>
<p>Pl. egy funktor, amelynek habár sok mindent nem csinál, példának jó lesz...
<a href="https://godbolt.org/z/dGaEG3brT">https://godbolt.org/z/dGaEG3brT</a></p>
<pre><code class="language-cpp">#include &lt;string&gt;
#include &lt;iostream&gt;

struct foo{
    foo() : x(0) {}

    void operator()(const std::string&amp; str = "") {
        std::cout &lt;&lt; "hello from foo, i've been called: " &lt;&lt; x &lt;&lt; " times before! You have said:" &lt;&lt; str &lt;&lt; '\n';
        x++;
    }

    private:
        int x;
};

int main(){
    foo f;
    f("hello!");
    f();
    f("bar");
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-c-standard-library"><a class="header" href="#a-c-standard-library">A C++ Standard Library</a></h1>
<p>A C++ Standard Library(gyakran STL, stdlib, stb.) alatt általában a C++ standard által meghatározott, C++ nyelvhez tartozó szabványos könyvtár egy implementációját értjük (pl libc++, libstdc++, MSVC STL).</p>
<h2 id="stl-tárolók"><a class="header" href="#stl-tárolók">STL Tárolók</a></h2>
<p>A standard tárolók fontosabb közös tulajdonságai:</p>
<ul>
<li>mind osztálysablonok(Standard <strong>Template</strong> Library)</li>
<li>begin és end iterátort visszaadó tagfüggvények foreach ciklushoz</li>
<li>at tagfüggvény (ahol értelmes)</li>
<li>indexelő operátor (ahol értelmes)</li>
</ul>
<h4 id="stdstring-1"><a class="header" href="#stdstring-1">std::string</a></h4>
<p><code>&lt;string&gt;</code> header</p>
<p>Egy egyszerű karakterlánc implementáció.</p>
<pre><code class="language-cpp">std::string str = "foo";

str.push_back("bar");
str[0] = 'l';

std::cout &lt;&lt; str;
</code></pre>
<h4 id="stdvector"><a class="header" href="#stdvector">std::vector</a></h4>
<p><code>&lt;vector&gt;</code> header</p>
<p>Egy általános dinamikus tömb típus. Nem mindig akkora helyet foglal, amennyire szüksége van, hanem kapacitás hiányában geometrikusan növeli a lefoglalt memória méretét(pl kétszerezi, vagy másfélszerezi)</p>
<pre><code class="language-cpp">std::vector&lt;int&gt; x = {1, 2, 3};

x.push_back(-5);

std::cout &lt;&lt; *x.begin() &lt;&lt; '\n';

for(int elem : x){
    std::cout &lt;&lt; elem &lt;&lt; ' ';
}
</code></pre>
<p>Az <code>at()</code> tagfüggvény kivételt dob, ha túlindexeljük a tárolót, az indexelő operátor viszont nem.</p>
<p>Van egy konstruktora, amely egyetlen pozitív egészet vesz át, ezzel előre foglalható valamennyi elem. Az előre foglalt elemek előre default-constructolva lesznek.</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;

int main(){
    std::vector&lt;int&gt; v(10);
    std::cout &lt;&lt; v.size();
}
</code></pre>
<h4 id="stdmap-és-stdunordered_map"><a class="header" href="#stdmap-és-stdunordered_map">std::map és std::unordered_map</a></h4>
<p><code>&lt;map&gt;</code> és <code>&lt;unordered_map&gt;</code> headerek</p>
<p>A <code>map</code> és <code>unordered_map</code> kulcs-érték párok tárolására való tárolók. A <code>map</code> garantált olvasási sorrendet kínál, míg az <code>unordered_map</code> nem, cserébe viszont gyorsabb.</p>
<p>Mindkét típus indexelő operátora beilleszti az adott kulcs-érték párt, ha az adott kulcs még nincs a tárolóban, ha pedig bent van, akkor megváltoztatja a hozzá tartozó értéket.</p>
<pre><code class="language-cpp">std::map&lt;std::string, int&gt; m;

m["foo"] = 5;
m["foo"] = 1;
std::cout &lt;&lt; m["foo"];
</code></pre>
<p>Az <code>at()</code> tagfüggvény nem így viselkedik, hanem kivételt dob, ha a kulcs nincs a tárolóban.</p>
<p>Azt, hogy egy kulcs a tárolóban van -e, a <code>contains(key)</code> tagfüggvénnyel ellenőrizhetjük.</p>
<h2 id="stl-algoritmusok"><a class="header" href="#stl-algoritmusok">STL algoritmusok</a></h2>
<p><code>&lt;algorithm&gt;</code> header</p>
<p>Az STL algoritmusok különböző típusú paraméterei:</p>
<ul>
<li><code>InIter</code> / <code>InputIt</code>: input iterátor</li>
<li><code>OutIter</code>: output iterátor</li>
<li><code>FwIter</code>: előre léptethető(Forward) iterátor</li>
<li><code>BiIter</code>: kétirányú(bidirectional) iterátor</li>
<li><code>RndIter</code>: Random Access iterátor(léptethető minden irányban akármekkora lépésben, pl. pointer, vektor iterátor)</li>
<li><code>Pred</code> / <code>UnaryPred</code>: egy operandusú predikátum</li>
<li><code>BinPred</code>: két operandusú predikátum</li>
<li><code>UnOp</code>: egy operandusú művelet</li>
<li><code>Cmp</code>: összehasonlító művelet</li>
</ul>
<p>Ezeket a nevek találhatók a tárgyhoz tartozó STL puskán is, de fejből nem kötelező tudni őket. Érdemes viszont átgondolni, mikor miért az adott típusú paraméterre van szükség.</p>
<h4 id="stdfind-stdfind_if"><a class="header" href="#stdfind-stdfind_if">std::find, std::find_if</a></h4>
<p><code>InputIt find( InputIt first, InputIt last, const T&amp; value );</code></p>
<p>Az <code>std::find</code> függvény két iterátort(a keresés doménjét), valamint egy értéket vesz át. A doménjében az <code>==</code> operátor segítségével keresi a kapott értéket, és ha megtalálja, akkor visszaad rá egy iterátort. Ha nem találja meg, akkor a domén végére mutató iterátort adja vissza.
Az ilyen iterátor párokat gyakran <em>range</em>-nek nevezzük.</p>
<pre><code class="language-cpp">    std::vector&lt;foo&gt; fs = {foo(1), foo(3), foo(-2)};

    auto find_iterator = std::find(fs.begin(), fs.end(), foo(3));
    if(find_iterator != fs.end()) {
        std::cout &lt;&lt; "foo(3) pozicio: " &lt;&lt; find_iterator - fs.begin() &lt;&lt; '\n';
    }else {
        std::cout &lt;&lt; "foo(3) -ra nincs talalat\n";
    }
</code></pre>
<p><code>InputIt find_if( InputIt first, InputIt last, UnaryPred p );</code></p>
<p>Az <code>std::find_if</code> 3. paraméterként egy érték helyett egy predikátumfüggvényt(vagy más függvényhívó operátorral rendelkező objektumot) vesz át, amely <code>bool</code> -t ad vissza és egyetlen paramétereként átveszi egy a doménben tárolt objektumok típusával megegyező típusú objektumot(<em>értsd: átveszi az éppen vizsgált elemet</em>).</p>
<pre><code class="language-cpp">    auto elter_2_iterator = std::find_if(fs.begin(), fs.end(), isDivisibleBy2);
    if(elter_2_iterator != fs.end()) {
        std::cout &lt;&lt; "foo(%2) pozicio: " &lt;&lt; elter_2_iterator - fs.begin() &lt;&lt; '\n';
    }else {
        std::cout &lt;&lt; "foo(%2) -re nincs talalat\n";
    }
</code></pre>
<h4 id="stdcount-és-stdcount_if"><a class="header" href="#stdcount-és-stdcount_if">std::count és std::count_if</a></h4>
<p><code>count( InputIt first, InputIt last, const T&amp; value );</code></p>
<p><code>count_if( InputIt first, InputIt last, UnaryPred p );</code></p>
<p>Ugyan az, mint a <code>find</code> és <code>find_if</code>, csak összeszámolja a feltételt kielégítő elemeket.</p>
<p><a href="https://godbolt.org/z/E17se46PG">https://godbolt.org/z/E17se46PG</a></p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

bool divisibleBy2(int x){
    return x % 2 == 0;
}

int main(){
    std::vector&lt;int&gt; v = {3, 2, 1, 5, 3, 2, 8, 3, 12};
    std::cout &lt;&lt; "3-asok szama: " &lt;&lt; std::count(v.begin(), v.end(), 3);
    std::cout &lt;&lt; "\n2-vel oszthatoak szama: " &lt;&lt; std::count_if(v.begin(), v.end(), divisibleBy2);
}
</code></pre>
<h4 id="stdfill-stdgenerate"><a class="header" href="#stdfill-stdgenerate">std::fill, std::generate</a></h4>
<p>Az <code>std::fill</code> feltölti a kapott range-t egy értékkel.</p>
<p><code>void fill( ForwardIt first, ForwardIt last, const T&amp; value );</code></p>
<p><a href="https://godbolt.org/z/7qbYq17v3">https://godbolt.org/z/7qbYq17v3</a></p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

int main(){
    std::vector&lt;int&gt; v(10); //előre foglalunk 10 objektumot, különben a range 0 elemű lenne
    std::fill(v.begin(), v.end(), 9); 
    for(auto&amp; elem : v){
        std::cout &lt;&lt; elem &lt;&lt; ' ';
    }
}
</code></pre>
<p>Az std::generate feltölti a kapott range-t értékekkel.
Ezt egy generátor segítségével teszi, amely a harmadik paramétere. A generátor paraméter nélkül hívható objektum, amely visszaadja a beillesztendő értéket.</p>
<p><code>void generate(ForwardIt first, ForwardIt last, Generator g);</code></p>
<p>Pl.
<a href="https://godbolt.org/z/Mz78oP4Wb">https://godbolt.org/z/Mz78oP4Wb</a></p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

struct generator{
    int x;
    generator() : x(0) {}

    int operator()(){
        return x++; //emlékezzünk vissza mit csinál a posztinkremens operátor(növeli, de régi értéket returnöl)
    }
};

int main(){
    std::vector&lt;int&gt; v(10); //előre foglalunk 10 objektumot, különben a range 0 elemű lenne
    generator g; //készítünk egy generátor példányt
    std::generate(v.begin(), v.end(), g); //átadjuk a generátort
    for(auto&amp; elem : v){
        std::cout &lt;&lt; elem &lt;&lt; ' ';
    }
}
</code></pre>
<p>A generálás gyakorlatilag a következőből áll:</p>
<pre><code class="language-cpp">for(auto it = v.begin(), it != v.end(), ++it){
    *it = g();
}
</code></pre>
<h4 id="stdequal-stdmismatch"><a class="header" href="#stdequal-stdmismatch">std::equal, std::mismatch</a></h4>
<p>Az <code>std::equal</code> megmondja, hogy két range minden eleme egyenlő -e.</p>
<p><code>bool equal(InputIt1 first1, InputIt1 last1, InputIt2 first2);</code></p>
<p><a href="https://godbolt.org/z/qsv57sPK5">https://godbolt.org/z/qsv57sPK5</a></p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

int main(){
    std::vector&lt;int&gt; v = {3, 2, 1, 5, 3, 2, 8, 3, 12};
    std::vector&lt;int&gt; w = {1, 4, 3, 2, 1, 7, 8, 9, 14};
    std::cout &lt;&lt; std::boolalpha &lt;&lt; std::equal(v.begin(), v.end(), w.begin(), w.end()) &lt;&lt; '\n';
    std::cout &lt;&lt; std::boolalpha &lt;&lt; std::equal(v.begin(), v.end(), v.begin(), v.end());
}
</code></pre>
<p>Az <code>std::mismatch</code> megkeresi az első olyan pontot két range-ben, ahol eltérnek.
Első három paramétere:</p>
<ul>
<li>Első range eleje</li>
<li>Első range vége</li>
<li>Második range eleje</li>
</ul>
<p>Opcionális negyedik paramétere egy predikátum, amely ha igazat ad vissza, mismatch-nek számít az adott elempár.</p>
<p><code>std::pair&lt;InputIt1, InputIt2&gt; mismatch( InputIt1 first1, InputIt1 last1, InputIt2 first2);</code></p>
<p><code>std::pair&lt;InputIt1, InputIt2&gt; mismatch(InputIt1 first1, InputIt1 last1, InputIt2 first2, BinaryPred p);</code></p>
<p>Visszatérési értéke egy <code>std::pair</code>, amely a két rangen belül a különbségre mutató iterátorokat tartalmazza.</p>
<p><a href="https://godbolt.org/z/hvdWTxqqr">https://godbolt.org/z/hvdWTxqqr</a></p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

template&lt;typename T&gt; //template hogy mindenféle vektorhoz jó legyen
struct transformer{
    T elozo;
    
    transformer() : elozo(0) {}

    T operator()(const T&amp; elem){
        int eredmeny = elem + elozo;
        elozo = elem;
        return eredmeny;
    }
};

int main(){
    std::vector&lt;int&gt; v = {3, 2, 1, 5, 3, 2, 8, 3, 12};
    std::vector&lt;int&gt; w = {3, 2, 1, 5, 0, 2, 8, 0, 12};
    
    auto it_pair = std::mismatch(v.begin(), v.end(), w.begin());
    std::cout &lt;&lt; "Mismatch at: " &lt;&lt; it_pair.first - v.begin();
}
</code></pre>
<h4 id="stdtransform"><a class="header" href="#stdtransform">std::transform</a></h4>
<p>Az <code>std::transform</code> végrehajt egy függvényt az adott range minden elemén és átmásolja egy másik rangebe. A függvény a range mindig aktuálisan változtatandó elemét veszi át.<br>
Első két paramétere a domén range eleje és vége, a hardmadik paramétere a másolás céljának eleje, a negyedik paraméter pedig a végrehajtandó művelet(függvény vagy funktor).</p>
<p><code>OutputIt transform(InputIt first1, InputIt last1, OutputIt d_first, UnaryOp unary_op);</code></p>
<p><a href="https://godbolt.org/z/WKE977c8P">https://godbolt.org/z/WKE977c8P</a></p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

template&lt;typename T&gt; //template hogy mindenféle vektorhoz jó legyen
struct transformer{
    T elozo;
    
    transformer() : elozo(0) {}

    T operator()(const T&amp; elem){
        int eredmeny = elem + elozo;
        elozo = elem;
        return eredmeny;
    }
};

int main(){
    std::vector&lt;int&gt; v = {3, 2, 1, 5, 3, 2, 8, 3, 12};
    std::vector&lt;int&gt; w(v.size());
    transformer&lt;int&gt; t;
    std::transform(v.begin(), v.end(), w.begin(), t);

    for(auto&amp; elem : w){
        std::cout &lt;&lt; elem &lt;&lt; ' ';
    }
}
</code></pre>
<p>Az <code>std::transform</code>-nak létezik egy két range-n működő változata is:</p>
<p><code>OutputIt transform(InputIt1 first1, InputIt1 last1, InputIt2 first2, OutputIt d_first, BinaryOp binary_op);</code></p>
<p><a href="https://godbolt.org/z/q96zb98Ea">https://godbolt.org/z/q96zb98Ea</a></p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

int main(){
    std::vector&lt;int&gt; v = {3, 2, 1, 5, 3, 2, 8, 3, 12};
    std::vector&lt;int&gt; w = {2, 5, 1, 5, 0, 2, 9, 0, 10};
    
    std::vector&lt;int&gt; x(v.size());

    //std::plus&lt;T&gt; : funktor aminek a fgv.hívás operátora összeadja a két operandust
    std::transform(v.begin(), v.end(), w.begin(), x.begin(), std::plus&lt;int&gt;()/*default constructed std::add instance*/);
    for(int elem : x){
        std::cout &lt;&lt; elem &lt;&lt; '\n';
    }
}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
